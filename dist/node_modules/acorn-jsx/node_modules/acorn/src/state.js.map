{"version":3,"sources":["../../../../../../node_modules/acorn-jsx/node_modules/acorn/src/state.js"],"names":["plugins","keywordRegexp","words","RegExp","replace","Parser","options","input","startPos","sourceFile","keywords","ecmaVersion","reserved","allowReserved","sourceType","reservedWords","reservedStrict","strict","reservedWordsStrict","reservedWordsStrictBind","strictBind","String","containsEsc","loadPlugins","pos","lineStart","Math","max","lastIndexOf","curLine","slice","split","length","type","eof","value","start","end","startLoc","endLoc","curPosition","lastTokEndLoc","lastTokStartLoc","lastTokStart","lastTokEnd","context","initialContext","exprAllowed","inModule","potentialArrowAt","inFunction","inGenerator","labels","allowHashBang","skipLineComment","word","test","name","f","pluginConfigs","plugin","Error","node","program","startNode","nextToken","parseTopLevel"],"mappings":"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","file":"state.js","sourcesContent":["import {reservedWords, keywords} from \"./identifier\"\nimport {types as tt} from \"./tokentype\"\nimport {lineBreak} from \"./whitespace\"\nimport {getOptions} from \"./options\"\n\n// Registered plugins\nexport const plugins = {}\n\nfunction keywordRegexp(words) {\n  return new RegExp(\"^(\" + words.replace(/ /g, \"|\") + \")$\")\n}\n\nexport class Parser {\n  constructor(options, input, startPos) {\n    this.options = options = getOptions(options)\n    this.sourceFile = options.sourceFile\n    this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5])\n    let reserved = options.allowReserved ? \"\" :\n        reservedWords[options.ecmaVersion] + (options.sourceType == \"module\" ? \" await\" : \"\")\n    this.reservedWords = keywordRegexp(reserved)\n    let reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict\n    this.reservedWordsStrict = keywordRegexp(reservedStrict)\n    this.reservedWordsStrictBind = keywordRegexp(reservedStrict + \" \" + reservedWords.strictBind)\n    this.input = String(input)\n\n    // Used to signal to callers of `readWord1` whether the word\n    // contained any escape sequences. This is needed because words with\n    // escape sequences must not be interpreted as keywords.\n    this.containsEsc = false\n\n    // Load plugins\n    this.loadPlugins(options.plugins)\n\n    // Set up token state\n\n    // The current position of the tokenizer in the input.\n    if (startPos) {\n      this.pos = startPos\n      this.lineStart = Math.max(0, this.input.lastIndexOf(\"\\n\", startPos))\n      this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length\n    } else {\n      this.pos = this.lineStart = 0\n      this.curLine = 1\n    }\n\n    // Properties of the current token:\n    // Its type\n    this.type = tt.eof\n    // For tokens that include more information than their type, the value\n    this.value = null\n    // Its start and end offset\n    this.start = this.end = this.pos\n    // And, if locations are used, the {line, column} object\n    // corresponding to those offsets\n    this.startLoc = this.endLoc = this.curPosition()\n\n    // Position information for the previous token\n    this.lastTokEndLoc = this.lastTokStartLoc = null\n    this.lastTokStart = this.lastTokEnd = this.pos\n\n    // The context stack is used to superficially track syntactic\n    // context to predict whether a regular expression is allowed in a\n    // given position.\n    this.context = this.initialContext()\n    this.exprAllowed = true\n\n    // Figure out if it's a module code.\n    this.strict = this.inModule = options.sourceType === \"module\"\n\n    // Used to signify the start of a potential arrow function\n    this.potentialArrowAt = -1\n\n    // Flags to track whether we are in a function, a generator.\n    this.inFunction = this.inGenerator = false\n    // Labels in scope.\n    this.labels = []\n\n    // If enabled, skip leading hashbang line.\n    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === '#!')\n      this.skipLineComment(2)\n  }\n\n  // DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them\n  isKeyword(word) { return this.keywords.test(word) }\n  isReservedWord(word) { return this.reservedWords.test(word) }\n\n  extend(name, f) {\n    this[name] = f(this[name])\n  }\n\n  loadPlugins(pluginConfigs) {\n    for (let name in pluginConfigs) {\n      let plugin = plugins[name]\n      if (!plugin) throw new Error(\"Plugin '\" + name + \"' not found\")\n      plugin(this, pluginConfigs[name])\n    }\n  }\n\n  parse() {\n    let node = this.options.program || this.startNode()\n    this.nextToken()\n    return this.parseTopLevel(node)\n  }\n}\n"]}