{"version":3,"sources":["../../../../node_modules/acorn/src/scope.js"],"names":["pp","prototype","assign","Object","target","sources","i","length","source","key","enterFunctionScope","scopeStack","push","var","lexical","childVar","parentLexical","exitFunctionScope","pop","enterLexicalScope","parentScope","childScope","exitLexicalScope","canDeclareVarName","name","currentScope","canDeclareLexicalName","declareVarName","declareLexicalName"],"mappings":"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","file":"scope.js","sourcesContent":["import {Parser} from \"./state\"\nimport {has} from \"./util\"\n\nconst pp = Parser.prototype\n\n// Object.assign polyfill\nconst assign = Object.assign || function(target, ...sources) {\n  for (let i = 0; i < sources.length; i++) {\n    const source = sources[i]\n    for (const key in source) {\n      if (has(source, key)) {\n        target[key] = source[key]\n      }\n    }\n  }\n  return target\n}\n\n// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\n\npp.enterFunctionScope = function() {\n  // var: a hash of var-declared names in the current lexical scope\n  // lexical: a hash of lexically-declared names in the current lexical scope\n  // childVar: a hash of var-declared names in all child lexical scopes of the current lexical scope (within the current function scope)\n  // parentLexical: a hash of lexically-declared names in all parent lexical scopes of the current lexical scope (within the current function scope)\n  this.scopeStack.push({var: {}, lexical: {}, childVar: {}, parentLexical: {}})\n}\n\npp.exitFunctionScope = function() {\n  this.scopeStack.pop()\n}\n\npp.enterLexicalScope = function() {\n  const parentScope = this.scopeStack[this.scopeStack.length - 1]\n  const childScope = {var: {}, lexical: {}, childVar: {}, parentLexical: {}}\n\n  this.scopeStack.push(childScope)\n  assign(childScope.parentLexical, parentScope.lexical, parentScope.parentLexical)\n}\n\npp.exitLexicalScope = function() {\n  const childScope = this.scopeStack.pop()\n  const parentScope = this.scopeStack[this.scopeStack.length - 1]\n\n  assign(parentScope.childVar, childScope.var, childScope.childVar)\n}\n\n/**\n * A name can be declared with `var` if there are no variables with the same name declared with `let`/`const`\n * in the current lexical scope or any of the parent lexical scopes in this function.\n */\npp.canDeclareVarName = function(name) {\n  const currentScope = this.scopeStack[this.scopeStack.length - 1]\n\n  return !has(currentScope.lexical, name) && !has(currentScope.parentLexical, name)\n}\n\n/**\n * A name can be declared with `let`/`const` if there are no variables with the same name declared with `let`/`const`\n * in the current scope, and there are no variables with the same name declared with `var` in the current scope or in\n * any child lexical scopes in this function.\n */\npp.canDeclareLexicalName = function(name) {\n  const currentScope = this.scopeStack[this.scopeStack.length - 1]\n\n  return !has(currentScope.lexical, name) && !has(currentScope.var, name) && !has(currentScope.childVar, name)\n}\n\npp.declareVarName = function(name) {\n  this.scopeStack[this.scopeStack.length - 1].var[name] = true\n}\n\npp.declareLexicalName = function(name) {\n  this.scopeStack[this.scopeStack.length - 1].lexical[name] = true\n}\n"]}