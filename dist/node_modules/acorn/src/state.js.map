{"version":3,"sources":["../../../../node_modules/acorn/src/state.js"],"names":["plugins","keywordRegexp","words","RegExp","replace","Parser","options","input","startPos","sourceFile","keywords","ecmaVersion","reserved","allowReserved","v","sourceType","reservedWords","reservedStrict","strict","reservedWordsStrict","reservedWordsStrictBind","strictBind","String","containsEsc","loadPlugins","pos","lineStart","lastIndexOf","curLine","slice","split","length","type","eof","value","start","end","startLoc","endLoc","curPosition","lastTokEndLoc","lastTokStartLoc","lastTokStart","lastTokEnd","context","initialContext","exprAllowed","inModule","strictDirective","potentialArrowAt","inFunction","inGenerator","inAsync","yieldPos","awaitPos","labels","allowHashBang","skipLineComment","scopeStack","enterFunctionScope","word","test","name","f","pluginConfigs","plugin","Error","node","program","startNode","nextToken","parseTopLevel"],"mappings":"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","file":"state.js","sourcesContent":["import {reservedWords, keywords} from \"./identifier\"\nimport {types as tt} from \"./tokentype\"\nimport {lineBreak} from \"./whitespace\"\nimport {getOptions} from \"./options\"\n\n// Registered plugins\nexport const plugins = {}\n\nfunction keywordRegexp(words) {\n  return new RegExp(\"^(\" + words.replace(/ /g, \"|\") + \")$\")\n}\n\nexport class Parser {\n  constructor(options, input, startPos) {\n    this.options = options = getOptions(options)\n    this.sourceFile = options.sourceFile\n    this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5])\n    let reserved = \"\"\n    if (!options.allowReserved) {\n      for (let v = options.ecmaVersion;; v--)\n        if (reserved = reservedWords[v]) break\n      if (options.sourceType == \"module\") reserved += \" await\"\n    }\n    this.reservedWords = keywordRegexp(reserved)\n    let reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict\n    this.reservedWordsStrict = keywordRegexp(reservedStrict)\n    this.reservedWordsStrictBind = keywordRegexp(reservedStrict + \" \" + reservedWords.strictBind)\n    this.input = String(input)\n\n    // Used to signal to callers of `readWord1` whether the word\n    // contained any escape sequences. This is needed because words with\n    // escape sequences must not be interpreted as keywords.\n    this.containsEsc = false\n\n    // Load plugins\n    this.loadPlugins(options.plugins)\n\n    // Set up token state\n\n    // The current position of the tokenizer in the input.\n    if (startPos) {\n      this.pos = startPos\n      this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1\n      this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length\n    } else {\n      this.pos = this.lineStart = 0\n      this.curLine = 1\n    }\n\n    // Properties of the current token:\n    // Its type\n    this.type = tt.eof\n    // For tokens that include more information than their type, the value\n    this.value = null\n    // Its start and end offset\n    this.start = this.end = this.pos\n    // And, if locations are used, the {line, column} object\n    // corresponding to those offsets\n    this.startLoc = this.endLoc = this.curPosition()\n\n    // Position information for the previous token\n    this.lastTokEndLoc = this.lastTokStartLoc = null\n    this.lastTokStart = this.lastTokEnd = this.pos\n\n    // The context stack is used to superficially track syntactic\n    // context to predict whether a regular expression is allowed in a\n    // given position.\n    this.context = this.initialContext()\n    this.exprAllowed = true\n\n    // Figure out if it's a module code.\n    this.inModule = options.sourceType === \"module\"\n    this.strict = this.inModule || this.strictDirective(this.pos)\n\n    // Used to signify the start of a potential arrow function\n    this.potentialArrowAt = -1\n\n    // Flags to track whether we are in a function, a generator, an async function.\n    this.inFunction = this.inGenerator = this.inAsync = false\n    // Positions to delayed-check that yield/await does not exist in default parameters.\n    this.yieldPos = this.awaitPos = 0\n    // Labels in scope.\n    this.labels = []\n\n    // If enabled, skip leading hashbang line.\n    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\")\n      this.skipLineComment(2)\n\n    // Scope tracking for duplicate variable names (see scope.js)\n    this.scopeStack = []\n    this.enterFunctionScope()\n  }\n\n  // DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them\n  isKeyword(word) { return this.keywords.test(word) }\n  isReservedWord(word) { return this.reservedWords.test(word) }\n\n  extend(name, f) {\n    this[name] = f(this[name])\n  }\n\n  loadPlugins(pluginConfigs) {\n    for (let name in pluginConfigs) {\n      let plugin = plugins[name]\n      if (!plugin) throw new Error(\"Plugin '\" + name + \"' not found\")\n      plugin(this, pluginConfigs[name])\n    }\n  }\n\n  parse() {\n    let node = this.options.program || this.startNode()\n    this.nextToken()\n    return this.parseTopLevel(node)\n  }\n}\n"]}