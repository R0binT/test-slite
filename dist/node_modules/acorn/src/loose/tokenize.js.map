{"version":3,"sources":["../../../../../node_modules/acorn/src/loose/tokenize.js"],"names":["lp","prototype","isSpace","ch","next","last","tok","ahead","length","shift","readToken","start","nextLineStart","curLineStart","lineEnd","curIndent","indentationAfter","toks","type","dot","input","substr","end","options","ecmaVersion","ellipsis","e","SyntaxError","msg","message","pos","raisedAt","replace","test","string","value","slice","re","RegExp","regexp","template","charCodeAt","resetTo","name","locations","loc","charAt","exprAllowed","curLine","lineStart","lastIndex","match","exec","index","lookAhead","n","push"],"mappings":"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","file":"tokenize.js","sourcesContent":["import {tokTypes as tt, Token, isNewLine, SourceLocation, getLineInfo, lineBreakG} from \"../index\"\nimport {LooseParser} from \"./state\"\n\nconst lp = LooseParser.prototype\n\nfunction isSpace(ch) {\n  return (ch < 14 && ch > 8) || ch === 32 || ch === 160 || isNewLine(ch)\n}\n\nlp.next = function() {\n  this.last = this.tok\n  if (this.ahead.length)\n    this.tok = this.ahead.shift()\n  else\n    this.tok = this.readToken()\n\n  if (this.tok.start >= this.nextLineStart) {\n    while (this.tok.start >= this.nextLineStart) {\n      this.curLineStart = this.nextLineStart\n      this.nextLineStart = this.lineEnd(this.curLineStart) + 1\n    }\n    this.curIndent = this.indentationAfter(this.curLineStart)\n  }\n}\n\nlp.readToken = function() {\n  for (;;) {\n    try {\n      this.toks.next()\n      if (this.toks.type === tt.dot &&\n          this.input.substr(this.toks.end, 1) === \".\" &&\n          this.options.ecmaVersion >= 6) {\n        this.toks.end++\n        this.toks.type = tt.ellipsis\n      }\n      return new Token(this.toks)\n    } catch (e) {\n      if (!(e instanceof SyntaxError)) throw e\n\n      // Try to skip some text, based on the error message, and then continue\n      let msg = e.message, pos = e.raisedAt, replace = true\n      if (/unterminated/i.test(msg)) {\n        pos = this.lineEnd(e.pos + 1)\n        if (/string/.test(msg)) {\n          replace = {start: e.pos, end: pos, type: tt.string, value: this.input.slice(e.pos + 1, pos)}\n        } else if (/regular expr/i.test(msg)) {\n          let re = this.input.slice(e.pos, pos)\n          try { re = new RegExp(re) } catch (e) { /* ignore compilation error due to new syntax */ }\n          replace = {start: e.pos, end: pos, type: tt.regexp, value: re}\n        } else if (/template/.test(msg)) {\n          replace = {\n            start: e.pos,\n            end: pos,\n            type: tt.template,\n            value: this.input.slice(e.pos, pos)\n          }\n        } else {\n          replace = false\n        }\n      } else if (/invalid (unicode|regexp|number)|expecting unicode|octal literal|is reserved|directly after number|expected number in radix/i.test(msg)) {\n        while (pos < this.input.length && !isSpace(this.input.charCodeAt(pos))) ++pos\n      } else if (/character escape|expected hexadecimal/i.test(msg)) {\n        while (pos < this.input.length) {\n          let ch = this.input.charCodeAt(pos++)\n          if (ch === 34 || ch === 39 || isNewLine(ch)) break\n        }\n      } else if (/unexpected character/i.test(msg)) {\n        pos++\n        replace = false\n      } else if (/regular expression/i.test(msg)) {\n        replace = true\n      } else {\n        throw e\n      }\n      this.resetTo(pos)\n      if (replace === true) replace = {start: pos, end: pos, type: tt.name, value: \"âœ–\"}\n      if (replace) {\n        if (this.options.locations)\n          replace.loc = new SourceLocation(\n            this.toks,\n            getLineInfo(this.input, replace.start),\n            getLineInfo(this.input, replace.end))\n        return replace\n      }\n    }\n  }\n}\n\nlp.resetTo = function(pos) {\n  this.toks.pos = pos\n  let ch = this.input.charAt(pos - 1)\n  this.toks.exprAllowed = !ch || /[[{(,;:?/*=+\\-~!|&%^<>]/.test(ch) ||\n    /[enwfd]/.test(ch) &&\n    /\\b(keywords|case|else|return|throw|new|in|(instance|type)of|delete|void)$/.test(this.input.slice(pos - 10, pos))\n\n  if (this.options.locations) {\n    this.toks.curLine = 1\n    this.toks.lineStart = lineBreakG.lastIndex = 0\n    let match\n    while ((match = lineBreakG.exec(this.input)) && match.index < pos) {\n      ++this.toks.curLine\n      this.toks.lineStart = match.index + match[0].length\n    }\n  }\n}\n\nlp.lookAhead = function(n) {\n  while (n > this.ahead.length)\n    this.ahead.push(this.readToken())\n  return this.ahead[n - 1]\n}\n"]}