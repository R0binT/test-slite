{"version":3,"sources":["../../../../node_modules/acorn/src/expression.js"],"names":["pp","prototype","checkPropClash","prop","propHash","options","ecmaVersion","computed","method","shorthand","key","name","type","String","value","kind","proto","raiseRecoverable","start","other","redefinition","strict","init","get","set","parseExpression","noIn","refDestructuringErrors","startPos","startLoc","expr","parseMaybeAssign","comma","node","startNodeAt","expressions","eat","push","finishNode","afterLeftParse","inGenerator","isContextual","parseYield","ownDestructuringErrors","oldParenAssign","oldTrailingComma","parenthesizedAssign","trailingComma","parenL","potentialArrowAt","left","parseMaybeConditional","call","isAssign","checkPatternErrors","operator","eq","toAssignable","shorthandAssign","checkLVal","next","right","checkExpressionErrors","parseExprOps","question","test","consequent","expect","colon","alternate","parseMaybeUnary","parseExprOp","leftStartPos","leftStartLoc","minPrec","prec","binop","_in","logical","logicalOR","logicalAND","op","buildBinary","sawUnary","inAsync","parseAwait","prefix","startNode","update","incDec","argument","parseExprSubscripts","postfix","canInsertSemicolon","starstar","parseExprAtom","skipArrowSubscripts","input","slice","lastTokStart","lastTokEnd","result","parseSubscripts","parenthesizedBind","base","noCalls","maybeAsyncArrow","end","bracketL","dot","object","property","parseIdent","bracketR","oldYieldPos","yieldPos","oldAwaitPos","awaitPos","exprList","parseExprList","parenR","arrow","checkYieldAwaitInDefaultParams","parseArrowExpression","callee","arguments","backQuote","tag","quasi","parseTemplate","canBeArrow","_super","inFunction","raise","_this","id","_function","parseFunction","unexpected","regexp","parseLiteral","regex","pattern","flags","num","string","_null","_true","_false","raw","keyword","parseParenAndDistinguishExpression","isSimpleAssignTarget","elements","braceL","parseObj","_class","parseClass","_new","parseNew","parseParenExpression","val","allowTrailingComma","innerStartPos","innerStartLoc","first","lastIsComma","spreadStart","innerParenStart","afterTrailingComma","ellipsis","parseParenItem","parseRest","innerEndPos","innerEndLoc","parseParenArrowList","length","finishNodeAt","preserveParens","par","expression","item","empty","meta","parseTemplateElement","elem","replace","cooked","tail","curElt","quasis","dollarBraceL","braceR","isPattern","properties","isGenerator","isAsync","star","parsePropertyName","parsePropertyValue","parseMaybeDefault","parseMethod","paramCount","params","keywords","reservedWordsStrict","reservedWords","initFunction","generator","async","oldInGen","oldInAsync","oldInFunc","enterFunctionScope","parseBindingList","parseFunctionBody","toAssignableList","isArrowFunction","isExpression","oldStrict","useStrict","body","checkParams","nonSimple","isSimpleParamList","strictDirective","oldLabels","labels","parseBlock","exitFunctionScope","i","allowDuplicates","nameHash","close","allowEmpty","elts","elt","parseSpread","liberal","allowReserved","indexOf","semi","startsExpr","delegate"],"mappings":"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","file":"expression.js","sourcesContent":["// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts — that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\nimport {types as tt} from \"./tokentype\"\nimport {Parser} from \"./state\"\nimport {DestructuringErrors} from \"./parseutil\"\n\nconst pp = Parser.prototype\n\n// Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash —\n// either with each other or with an init property — and in\n// strict mode, init properties are also not allowed to be repeated.\n\npp.checkPropClash = function(prop, propHash) {\n  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\n    return\n  let {key} = prop, name\n  switch (key.type) {\n  case \"Identifier\": name = key.name; break\n  case \"Literal\": name = String(key.value); break\n  default: return\n  }\n  let {kind} = prop\n  if (this.options.ecmaVersion >= 6) {\n    if (name === \"__proto__\" && kind === \"init\") {\n      if (propHash.proto) this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\")\n      propHash.proto = true\n    }\n    return\n  }\n  name = \"$\" + name\n  let other = propHash[name]\n  if (other) {\n    let redefinition\n    if (kind === \"init\") {\n      redefinition = this.strict && other.init || other.get || other.set\n    } else {\n      redefinition = other.init || other[kind]\n    }\n    if (redefinition)\n      this.raiseRecoverable(key.start, \"Redefinition of property\")\n  } else {\n    other = propHash[name] = {\n      init: false,\n      get: false,\n      set: false\n    }\n  }\n  other[kind] = true\n}\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function(s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initalization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\n\npp.parseExpression = function(noIn, refDestructuringErrors) {\n  let startPos = this.start, startLoc = this.startLoc\n  let expr = this.parseMaybeAssign(noIn, refDestructuringErrors)\n  if (this.type === tt.comma) {\n    let node = this.startNodeAt(startPos, startLoc)\n    node.expressions = [expr]\n    while (this.eat(tt.comma)) node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors))\n    return this.finishNode(node, \"SequenceExpression\")\n  }\n  return expr\n}\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n\npp.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\n  if (this.inGenerator && this.isContextual(\"yield\")) return this.parseYield()\n\n  let ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1\n  if (refDestructuringErrors) {\n    oldParenAssign = refDestructuringErrors.parenthesizedAssign\n    oldTrailingComma = refDestructuringErrors.trailingComma\n    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1\n  } else {\n    refDestructuringErrors = new DestructuringErrors\n    ownDestructuringErrors = true\n  }\n\n  let startPos = this.start, startLoc = this.startLoc\n  if (this.type == tt.parenL || this.type == tt.name)\n    this.potentialArrowAt = this.start\n  let left = this.parseMaybeConditional(noIn, refDestructuringErrors)\n  if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc)\n  if (this.type.isAssign) {\n    this.checkPatternErrors(refDestructuringErrors, true)\n    if (!ownDestructuringErrors) DestructuringErrors.call(refDestructuringErrors)\n    let node = this.startNodeAt(startPos, startLoc)\n    node.operator = this.value\n    node.left = this.type === tt.eq ? this.toAssignable(left) : left\n    refDestructuringErrors.shorthandAssign = -1 // reset because shorthand default was used correctly\n    this.checkLVal(left)\n    this.next()\n    node.right = this.parseMaybeAssign(noIn)\n    return this.finishNode(node, \"AssignmentExpression\")\n  } else {\n    if (ownDestructuringErrors) this.checkExpressionErrors(refDestructuringErrors, true)\n  }\n  if (oldParenAssign > -1) refDestructuringErrors.parenthesizedAssign = oldParenAssign\n  if (oldTrailingComma > -1) refDestructuringErrors.trailingComma = oldTrailingComma\n  return left\n}\n\n// Parse a ternary conditional (`?:`) operator.\n\npp.parseMaybeConditional = function(noIn, refDestructuringErrors) {\n  let startPos = this.start, startLoc = this.startLoc\n  let expr = this.parseExprOps(noIn, refDestructuringErrors)\n  if (this.checkExpressionErrors(refDestructuringErrors)) return expr\n  if (this.eat(tt.question)) {\n    let node = this.startNodeAt(startPos, startLoc)\n    node.test = expr\n    node.consequent = this.parseMaybeAssign()\n    this.expect(tt.colon)\n    node.alternate = this.parseMaybeAssign(noIn)\n    return this.finishNode(node, \"ConditionalExpression\")\n  }\n  return expr\n}\n\n// Start the precedence parser.\n\npp.parseExprOps = function(noIn, refDestructuringErrors) {\n  let startPos = this.start, startLoc = this.startLoc\n  let expr = this.parseMaybeUnary(refDestructuringErrors, false)\n  if (this.checkExpressionErrors(refDestructuringErrors)) return expr\n  return expr.start == startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)\n}\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\n\npp.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n  let prec = this.type.binop\n  if (prec != null && (!noIn || this.type !== tt._in)) {\n    if (prec > minPrec) {\n      let logical = this.type === tt.logicalOR || this.type === tt.logicalAND\n      let op = this.value\n      this.next()\n      let startPos = this.start, startLoc = this.startLoc\n      let right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn)\n      let node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical)\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)\n    }\n  }\n  return left\n}\n\npp.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n  let node = this.startNodeAt(startPos, startLoc)\n  node.left = left\n  node.operator = op\n  node.right = right\n  return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\")\n}\n\n// Parse unary operators, both prefix and postfix.\n\npp.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {\n  let startPos = this.start, startLoc = this.startLoc, expr\n  if (this.inAsync && this.isContextual(\"await\")) {\n    expr = this.parseAwait(refDestructuringErrors)\n    sawUnary = true\n  } else if (this.type.prefix) {\n    let node = this.startNode(), update = this.type === tt.incDec\n    node.operator = this.value\n    node.prefix = true\n    this.next()\n    node.argument = this.parseMaybeUnary(null, true)\n    this.checkExpressionErrors(refDestructuringErrors, true)\n    if (update) this.checkLVal(node.argument)\n    else if (this.strict && node.operator === \"delete\" &&\n             node.argument.type === \"Identifier\")\n      this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\")\n    else sawUnary = true\n    expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\")\n  } else {\n    expr = this.parseExprSubscripts(refDestructuringErrors)\n    if (this.checkExpressionErrors(refDestructuringErrors)) return expr\n    while (this.type.postfix && !this.canInsertSemicolon()) {\n      let node = this.startNodeAt(startPos, startLoc)\n      node.operator = this.value\n      node.prefix = false\n      node.argument = expr\n      this.checkLVal(expr)\n      this.next()\n      expr = this.finishNode(node, \"UpdateExpression\")\n    }\n  }\n\n  if (!sawUnary && this.eat(tt.starstar))\n    return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false)\n  else\n    return expr\n}\n\n// Parse call, dot, and `[]`-subscript expressions.\n\npp.parseExprSubscripts = function(refDestructuringErrors) {\n  let startPos = this.start, startLoc = this.startLoc\n  let expr = this.parseExprAtom(refDestructuringErrors)\n  let skipArrowSubscripts = expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\"\n  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) return expr\n  let result = this.parseSubscripts(expr, startPos, startLoc)\n  if (refDestructuringErrors && result.type === \"MemberExpression\") {\n    if (refDestructuringErrors.parenthesizedAssign >= result.start) refDestructuringErrors.parenthesizedAssign = -1\n    if (refDestructuringErrors.parenthesizedBind >= result.start) refDestructuringErrors.parenthesizedBind = -1\n  }\n  return result\n}\n\npp.parseSubscripts = function(base, startPos, startLoc, noCalls) {\n  let maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" &&\n      this.lastTokEnd == base.end && !this.canInsertSemicolon()\n  for (let computed;;) {\n    if ((computed = this.eat(tt.bracketL)) || this.eat(tt.dot)) {\n      let node = this.startNodeAt(startPos, startLoc)\n      node.object = base\n      node.property = computed ? this.parseExpression() : this.parseIdent(true)\n      node.computed = !!computed\n      if (computed) this.expect(tt.bracketR)\n      base = this.finishNode(node, \"MemberExpression\")\n    } else if (!noCalls && this.eat(tt.parenL)) {\n      let refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos\n      this.yieldPos = 0\n      this.awaitPos = 0\n      let exprList = this.parseExprList(tt.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors)\n      if (maybeAsyncArrow && !this.canInsertSemicolon() && this.eat(tt.arrow)) {\n        this.checkPatternErrors(refDestructuringErrors, false)\n        this.checkYieldAwaitInDefaultParams()\n        this.yieldPos = oldYieldPos\n        this.awaitPos = oldAwaitPos\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)\n      }\n      this.checkExpressionErrors(refDestructuringErrors, true)\n      this.yieldPos = oldYieldPos || this.yieldPos\n      this.awaitPos = oldAwaitPos || this.awaitPos\n      let node = this.startNodeAt(startPos, startLoc)\n      node.callee = base\n      node.arguments = exprList\n      base = this.finishNode(node, \"CallExpression\")\n    } else if (this.type === tt.backQuote) {\n      let node = this.startNodeAt(startPos, startLoc)\n      node.tag = base\n      node.quasi = this.parseTemplate()\n      base = this.finishNode(node, \"TaggedTemplateExpression\")\n    } else {\n      return base\n    }\n  }\n}\n\n// Parse an atomic expression — either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n\npp.parseExprAtom = function(refDestructuringErrors) {\n  let node, canBeArrow = this.potentialArrowAt == this.start\n  switch (this.type) {\n  case tt._super:\n    if (!this.inFunction)\n      this.raise(this.start, \"'super' outside of function or class\")\n\n  case tt._this:\n    let type = this.type === tt._this ? \"ThisExpression\" : \"Super\"\n    node = this.startNode()\n    this.next()\n    return this.finishNode(node, type)\n\n  case tt.name:\n    let startPos = this.start, startLoc = this.startLoc\n    let id = this.parseIdent(this.type !== tt.name)\n    if (this.options.ecmaVersion >= 8 && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(tt._function))\n      return this.parseFunction(this.startNodeAt(startPos, startLoc), false, false, true)\n    if (canBeArrow && !this.canInsertSemicolon()) {\n      if (this.eat(tt.arrow))\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false)\n      if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === tt.name) {\n        id = this.parseIdent()\n        if (this.canInsertSemicolon() || !this.eat(tt.arrow))\n          this.unexpected()\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)\n      }\n    }\n    return id\n\n  case tt.regexp:\n    let value = this.value\n    node = this.parseLiteral(value.value)\n    node.regex = {pattern: value.pattern, flags: value.flags}\n    return node\n\n  case tt.num: case tt.string:\n    return this.parseLiteral(this.value)\n\n  case tt._null: case tt._true: case tt._false:\n    node = this.startNode()\n    node.value = this.type === tt._null ? null : this.type === tt._true\n    node.raw = this.type.keyword\n    this.next()\n    return this.finishNode(node, \"Literal\")\n\n  case tt.parenL:\n    let start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow)\n    if (refDestructuringErrors) {\n      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))\n        refDestructuringErrors.parenthesizedAssign = start\n      if (refDestructuringErrors.parenthesizedBind < 0)\n        refDestructuringErrors.parenthesizedBind = start\n    }\n    return expr\n\n  case tt.bracketL:\n    node = this.startNode()\n    this.next()\n    node.elements = this.parseExprList(tt.bracketR, true, true, refDestructuringErrors)\n    return this.finishNode(node, \"ArrayExpression\")\n\n  case tt.braceL:\n    return this.parseObj(false, refDestructuringErrors)\n\n  case tt._function:\n    node = this.startNode()\n    this.next()\n    return this.parseFunction(node, false)\n\n  case tt._class:\n    return this.parseClass(this.startNode(), false)\n\n  case tt._new:\n    return this.parseNew()\n\n  case tt.backQuote:\n    return this.parseTemplate()\n\n  default:\n    this.unexpected()\n  }\n}\n\npp.parseLiteral = function(value) {\n  let node = this.startNode()\n  node.value = value\n  node.raw = this.input.slice(this.start, this.end)\n  this.next()\n  return this.finishNode(node, \"Literal\")\n}\n\npp.parseParenExpression = function() {\n  this.expect(tt.parenL)\n  let val = this.parseExpression()\n  this.expect(tt.parenR)\n  return val\n}\n\npp.parseParenAndDistinguishExpression = function(canBeArrow) {\n  let startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8\n  if (this.options.ecmaVersion >= 6) {\n    this.next()\n\n    let innerStartPos = this.start, innerStartLoc = this.startLoc\n    let exprList = [], first = true, lastIsComma = false\n    let refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart, innerParenStart\n    this.yieldPos = 0\n    this.awaitPos = 0\n    while (this.type !== tt.parenR) {\n      first ? first = false : this.expect(tt.comma)\n      if (allowTrailingComma && this.afterTrailingComma(tt.parenR, true)) {\n        lastIsComma = true\n        break\n      } else if (this.type === tt.ellipsis) {\n        spreadStart = this.start\n        exprList.push(this.parseParenItem(this.parseRest()))\n        if (this.type === tt.comma) this.raise(this.start, \"Comma is not permitted after the rest element\")\n        break\n      } else {\n        if (this.type === tt.parenL && !innerParenStart) {\n          innerParenStart = this.start\n        }\n        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem))\n      }\n    }\n    let innerEndPos = this.start, innerEndLoc = this.startLoc\n    this.expect(tt.parenR)\n\n    if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow)) {\n      this.checkPatternErrors(refDestructuringErrors, false)\n      this.checkYieldAwaitInDefaultParams()\n      if (innerParenStart) this.unexpected(innerParenStart)\n      this.yieldPos = oldYieldPos\n      this.awaitPos = oldAwaitPos\n      return this.parseParenArrowList(startPos, startLoc, exprList)\n    }\n\n    if (!exprList.length || lastIsComma) this.unexpected(this.lastTokStart)\n    if (spreadStart) this.unexpected(spreadStart)\n    this.checkExpressionErrors(refDestructuringErrors, true)\n    this.yieldPos = oldYieldPos || this.yieldPos\n    this.awaitPos = oldAwaitPos || this.awaitPos\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc)\n      val.expressions = exprList\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc)\n    } else {\n      val = exprList[0]\n    }\n  } else {\n    val = this.parseParenExpression()\n  }\n\n  if (this.options.preserveParens) {\n    let par = this.startNodeAt(startPos, startLoc)\n    par.expression = val\n    return this.finishNode(par, \"ParenthesizedExpression\")\n  } else {\n    return val\n  }\n}\n\npp.parseParenItem = function(item) {\n  return item\n}\n\npp.parseParenArrowList = function(startPos, startLoc, exprList) {\n  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)\n}\n\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call — at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\n\nconst empty = []\n\npp.parseNew = function() {\n  let node = this.startNode()\n  let meta = this.parseIdent(true)\n  if (this.options.ecmaVersion >= 6 && this.eat(tt.dot)) {\n    node.meta = meta\n    node.property = this.parseIdent(true)\n    if (node.property.name !== \"target\")\n      this.raiseRecoverable(node.property.start, \"The only valid meta property for new is new.target\")\n    if (!this.inFunction)\n      this.raiseRecoverable(node.start, \"new.target can only be used in functions\")\n    return this.finishNode(node, \"MetaProperty\")\n  }\n  let startPos = this.start, startLoc = this.startLoc\n  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true)\n  if (this.eat(tt.parenL)) node.arguments = this.parseExprList(tt.parenR, this.options.ecmaVersion >= 8, false)\n  else node.arguments = empty\n  return this.finishNode(node, \"NewExpression\")\n}\n\n// Parse template expression.\n\npp.parseTemplateElement = function() {\n  let elem = this.startNode()\n  elem.value = {\n    raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n    cooked: this.value\n  }\n  this.next()\n  elem.tail = this.type === tt.backQuote\n  return this.finishNode(elem, \"TemplateElement\")\n}\n\npp.parseTemplate = function() {\n  let node = this.startNode()\n  this.next()\n  node.expressions = []\n  let curElt = this.parseTemplateElement()\n  node.quasis = [curElt]\n  while (!curElt.tail) {\n    this.expect(tt.dollarBraceL)\n    node.expressions.push(this.parseExpression())\n    this.expect(tt.braceR)\n    node.quasis.push(curElt = this.parseTemplateElement())\n  }\n  this.next()\n  return this.finishNode(node, \"TemplateLiteral\")\n}\n\n// Parse an object literal or binding pattern.\n\npp.parseObj = function(isPattern, refDestructuringErrors) {\n  let node = this.startNode(), first = true, propHash = {}\n  node.properties = []\n  this.next()\n  while (!this.eat(tt.braceR)) {\n    if (!first) {\n      this.expect(tt.comma)\n      if (this.afterTrailingComma(tt.braceR)) break\n    } else first = false\n\n    let prop = this.startNode(), isGenerator, isAsync, startPos, startLoc\n    if (this.options.ecmaVersion >= 6) {\n      prop.method = false\n      prop.shorthand = false\n      if (isPattern || refDestructuringErrors) {\n        startPos = this.start\n        startLoc = this.startLoc\n      }\n      if (!isPattern)\n        isGenerator = this.eat(tt.star)\n    }\n    this.parsePropertyName(prop)\n    if (!isPattern && this.options.ecmaVersion >= 8 && !isGenerator && !prop.computed &&\n        prop.key.type === \"Identifier\" && prop.key.name === \"async\" && this.type !== tt.parenL &&\n        this.type !== tt.colon && !this.canInsertSemicolon()) {\n      isAsync = true\n      this.parsePropertyName(prop, refDestructuringErrors)\n    } else {\n      isAsync = false\n    }\n    this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors)\n    this.checkPropClash(prop, propHash)\n    node.properties.push(this.finishNode(prop, \"Property\"))\n  }\n  return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\n}\n\npp.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors) {\n  if ((isGenerator || isAsync) && this.type === tt.colon)\n    this.unexpected()\n\n  if (this.eat(tt.colon)) {\n    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors)\n    prop.kind = \"init\"\n  } else if (this.options.ecmaVersion >= 6 && this.type === tt.parenL) {\n    if (isPattern) this.unexpected()\n    prop.kind = \"init\"\n    prop.method = true\n    prop.value = this.parseMethod(isGenerator, isAsync)\n  } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\n             (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n             (this.type != tt.comma && this.type != tt.braceR)) {\n    if (isGenerator || isAsync || isPattern) this.unexpected()\n    prop.kind = prop.key.name\n    this.parsePropertyName(prop)\n    prop.value = this.parseMethod(false)\n    let paramCount = prop.kind === \"get\" ? 0 : 1\n    if (prop.value.params.length !== paramCount) {\n      let start = prop.value.start\n      if (prop.kind === \"get\")\n        this.raiseRecoverable(start, \"getter should have no params\")\n      else\n        this.raiseRecoverable(start, \"setter should have exactly one param\")\n    } else {\n      if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\n        this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\")\n    }\n  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n    if (this.keywords.test(prop.key.name) ||\n        (this.strict ? this.reservedWordsStrict : this.reservedWords).test(prop.key.name) ||\n        (this.inGenerator && prop.key.name == \"yield\") ||\n        (this.inAsync && prop.key.name == \"await\"))\n      this.raiseRecoverable(prop.key.start, \"'\" + prop.key.name + \"' can not be used as shorthand property\")\n    prop.kind = \"init\"\n    if (isPattern) {\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)\n    } else if (this.type === tt.eq && refDestructuringErrors) {\n      if (refDestructuringErrors.shorthandAssign < 0)\n        refDestructuringErrors.shorthandAssign = this.start\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)\n    } else {\n      prop.value = prop.key\n    }\n    prop.shorthand = true\n  } else this.unexpected()\n}\n\npp.parsePropertyName = function(prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(tt.bracketL)) {\n      prop.computed = true\n      prop.key = this.parseMaybeAssign()\n      this.expect(tt.bracketR)\n      return prop.key\n    } else {\n      prop.computed = false\n    }\n  }\n  return prop.key = this.type === tt.num || this.type === tt.string ? this.parseExprAtom() : this.parseIdent(true)\n}\n\n// Initialize empty function node.\n\npp.initFunction = function(node) {\n  node.id = null\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = false\n    node.expression = false\n  }\n  if (this.options.ecmaVersion >= 8)\n    node.async = false\n}\n\n// Parse object or class method.\n\npp.parseMethod = function(isGenerator, isAsync) {\n  let node = this.startNode(), oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction\n\n  this.initFunction(node)\n  if (this.options.ecmaVersion >= 6)\n    node.generator = isGenerator\n  if (this.options.ecmaVersion >= 8)\n    node.async = !!isAsync\n\n  this.inGenerator = node.generator\n  this.inAsync = node.async\n  this.yieldPos = 0\n  this.awaitPos = 0\n  this.inFunction = true\n  this.enterFunctionScope()\n\n  this.expect(tt.parenL)\n  node.params = this.parseBindingList(tt.parenR, false, this.options.ecmaVersion >= 8)\n  this.checkYieldAwaitInDefaultParams()\n  this.parseFunctionBody(node, false)\n\n  this.inGenerator = oldInGen\n  this.inAsync = oldInAsync\n  this.yieldPos = oldYieldPos\n  this.awaitPos = oldAwaitPos\n  this.inFunction = oldInFunc\n  return this.finishNode(node, \"FunctionExpression\")\n}\n\n// Parse arrow function expression with given parameters.\n\npp.parseArrowExpression = function(node, params, isAsync) {\n  let oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction\n\n  this.enterFunctionScope()\n  this.initFunction(node)\n  if (this.options.ecmaVersion >= 8)\n    node.async = !!isAsync\n\n  this.inGenerator = false\n  this.inAsync = node.async\n  this.yieldPos = 0\n  this.awaitPos = 0\n  this.inFunction = true\n\n  node.params = this.toAssignableList(params, true)\n  this.parseFunctionBody(node, true)\n\n  this.inGenerator = oldInGen\n  this.inAsync = oldInAsync\n  this.yieldPos = oldYieldPos\n  this.awaitPos = oldAwaitPos\n  this.inFunction = oldInFunc\n  return this.finishNode(node, \"ArrowFunctionExpression\")\n}\n\n// Parse function body and check parameters.\n\npp.parseFunctionBody = function(node, isArrowFunction) {\n  let isExpression = isArrowFunction && this.type !== tt.braceL\n  let oldStrict = this.strict, useStrict = false\n\n  if (isExpression) {\n    node.body = this.parseMaybeAssign()\n    node.expression = true\n    this.checkParams(node, false)\n  } else {\n    let nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params)\n    if (!oldStrict || nonSimple) {\n      useStrict = this.strictDirective(this.end)\n      // If this is a strict mode function, verify that argument names\n      // are not repeated, and it does not try to bind the words `eval`\n      // or `arguments`.\n      if (useStrict && nonSimple)\n        this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\")\n    }\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    let oldLabels = this.labels\n    this.labels = []\n    if (useStrict) this.strict = true\n\n    // Add the params to varDeclaredNames to ensure that an error is thrown\n    // if a let/const declaration in the function clashes with one of the params.\n    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && this.isSimpleParamList(node.params))\n    node.body = this.parseBlock(false)\n    node.expression = false\n    this.labels = oldLabels\n  }\n  this.exitFunctionScope()\n\n  if (this.strict && node.id) {\n    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n    this.checkLVal(node.id, \"none\")\n  }\n  this.strict = oldStrict\n}\n\npp.isSimpleParamList = function(params) {\n  for (let i = 0; i < params.length; i++)\n    if (params[i].type !== \"Identifier\") return false\n  return true\n}\n\n// Checks function params for various disallowed patterns such as using \"eval\"\n// or \"arguments\" and duplicate parameters.\n\npp.checkParams = function(node, allowDuplicates) {\n  let nameHash = {}\n  for (let i = 0; i < node.params.length; i++) this.checkLVal(node.params[i], \"var\", allowDuplicates ? null : nameHash)\n}\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\npp.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n  let elts = [], first = true\n  while (!this.eat(close)) {\n    if (!first) {\n      this.expect(tt.comma)\n      if (allowTrailingComma && this.afterTrailingComma(close)) break\n    } else first = false\n\n    let elt\n    if (allowEmpty && this.type === tt.comma)\n      elt = null\n    else if (this.type === tt.ellipsis) {\n      elt = this.parseSpread(refDestructuringErrors)\n      if (refDestructuringErrors && this.type === tt.comma && refDestructuringErrors.trailingComma < 0)\n        refDestructuringErrors.trailingComma = this.start\n    } else {\n      elt = this.parseMaybeAssign(false, refDestructuringErrors)\n    }\n    elts.push(elt)\n  }\n  return elts\n}\n\n// Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\n\npp.parseIdent = function(liberal) {\n  let node = this.startNode()\n  if (liberal && this.options.allowReserved == \"never\") liberal = false\n  if (this.type === tt.name) {\n    if (!liberal && (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) &&\n        (this.options.ecmaVersion >= 6 ||\n         this.input.slice(this.start, this.end).indexOf(\"\\\\\") == -1))\n      this.raiseRecoverable(this.start, \"The keyword '\" + this.value + \"' is reserved\")\n    if (this.inGenerator && this.value === \"yield\")\n      this.raiseRecoverable(this.start, \"Can not use 'yield' as identifier inside a generator\")\n    if (this.inAsync && this.value === \"await\")\n      this.raiseRecoverable(this.start, \"Can not use 'await' as identifier inside an async function\")\n    node.name = this.value\n  } else if (liberal && this.type.keyword) {\n    node.name = this.type.keyword\n  } else {\n    this.unexpected()\n  }\n  this.next()\n  return this.finishNode(node, \"Identifier\")\n}\n\n// Parses yield expression inside generator.\n\npp.parseYield = function() {\n  if (!this.yieldPos) this.yieldPos = this.start\n\n  let node = this.startNode()\n  this.next()\n  if (this.type == tt.semi || this.canInsertSemicolon() || (this.type != tt.star && !this.type.startsExpr)) {\n    node.delegate = false\n    node.argument = null\n  } else {\n    node.delegate = this.eat(tt.star)\n    node.argument = this.parseMaybeAssign()\n  }\n  return this.finishNode(node, \"YieldExpression\")\n}\n\npp.parseAwait = function() {\n  if (!this.awaitPos) this.awaitPos = this.start\n\n  let node = this.startNode()\n  this.next()\n  node.argument = this.parseMaybeUnary(null, true)\n  return this.finishNode(node, \"AwaitExpression\")\n}\n"]}