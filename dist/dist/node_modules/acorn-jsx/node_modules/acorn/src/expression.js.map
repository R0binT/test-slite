{"version":3,"sources":["../../../../../../node_modules/acorn-jsx/node_modules/acorn/src/expression.js"],"names":["pp","prototype","checkPropClash","prop","propHash","options","ecmaVersion","computed","method","shorthand","key","name","type","String","value","kind","proto","raiseRecoverable","start","other","isGetSet","strict","init","get","set","parseExpression","noIn","refDestructuringErrors","startPos","startLoc","expr","parseMaybeAssign","comma","node","startNodeAt","expressions","eat","push","finishNode","afterLeftParse","inGenerator","isContextual","parseYield","ownDestructuringErrors","parenL","potentialArrowAt","left","parseMaybeConditional","call","isAssign","checkPatternErrors","operator","eq","toAssignable","shorthandAssign","checkLVal","next","right","checkExpressionErrors","parseExprOps","question","test","consequent","expect","colon","alternate","parseMaybeUnary","parseExprOp","leftStartPos","leftStartLoc","minPrec","prec","binop","_in","logical","logicalOR","logicalAND","op","buildBinary","sawUnary","prefix","startNode","update","incDec","argument","parseExprSubscripts","postfix","canInsertSemicolon","starstar","parseExprAtom","skipArrowSubscripts","input","slice","lastTokStart","lastTokEnd","parseSubscripts","base","noCalls","dot","object","property","parseIdent","bracketL","bracketR","callee","arguments","parseExprList","parenR","backQuote","tag","quasi","parseTemplate","canBeArrow","_super","inFunction","raise","_this","id","arrow","parseArrowExpression","regexp","parseLiteral","regex","pattern","flags","num","string","_null","_true","_false","raw","keyword","parseParenAndDistinguishExpression","elements","braceL","parseObj","_function","parseFunction","_class","parseClass","_new","parseNew","unexpected","end","parseParenExpression","val","innerStartPos","innerStartLoc","exprList","first","spreadStart","innerParenStart","ellipsis","parseParenItem","parseRest","innerEndPos","innerEndLoc","parseParenArrowList","length","finishNodeAt","preserveParens","par","expression","item","empty","meta","parseTemplateElement","elem","replace","cooked","tail","curElt","quasis","dollarBraceL","braceR","isPattern","properties","afterTrailingComma","isGenerator","star","parsePropertyName","parsePropertyValue","parseMaybeDefault","parseMethod","paramCount","params","keywords","reservedWordsStrictBind","reservedWords","initFunction","generator","oldInGen","parseBindingList","parseFunctionBody","toAssignableList","isArrowFunction","isExpression","body","oldInFunc","oldLabels","labels","parseBlock","useStrict","isUseStrict","oldStrict","checkParams","nameHash","i","close","allowTrailingComma","allowEmpty","elts","elt","parseSpread","trailingComma","liberal","allowReserved","reservedWordsStrict","indexOf","semi","startsExpr","delegate"],"mappings":"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","file":"expression.js","sourcesContent":["// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts — that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\nimport {types as tt} from \"./tokentype\"\nimport {Parser} from \"./state\"\nimport {DestructuringErrors} from \"./parseutil\"\n\nconst pp = Parser.prototype\n\n// Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash —\n// either with each other or with an init property — and in\n// strict mode, init properties are also not allowed to be repeated.\n\npp.checkPropClash = function(prop, propHash) {\n  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\n    return\n  let {key} = prop, name\n  switch (key.type) {\n  case \"Identifier\": name = key.name; break\n  case \"Literal\": name = String(key.value); break\n  default: return\n  }\n  let {kind} = prop\n  if (this.options.ecmaVersion >= 6) {\n    if (name === \"__proto__\" && kind === \"init\") {\n      if (propHash.proto) this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\")\n      propHash.proto = true\n    }\n    return\n  }\n  name = \"$\" + name\n  let other = propHash[name]\n  if (other) {\n    let isGetSet = kind !== \"init\"\n    if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init))\n      this.raiseRecoverable(key.start, \"Redefinition of property\")\n  } else {\n    other = propHash[name] = {\n      init: false,\n      get: false,\n      set: false\n    }\n  }\n  other[kind] = true\n}\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function(s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initalization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\n\npp.parseExpression = function(noIn, refDestructuringErrors) {\n  let startPos = this.start, startLoc = this.startLoc\n  let expr = this.parseMaybeAssign(noIn, refDestructuringErrors)\n  if (this.type === tt.comma) {\n    let node = this.startNodeAt(startPos, startLoc)\n    node.expressions = [expr]\n    while (this.eat(tt.comma)) node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors))\n    return this.finishNode(node, \"SequenceExpression\")\n  }\n  return expr\n}\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n\npp.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\n  if (this.inGenerator && this.isContextual(\"yield\")) return this.parseYield()\n\n  let ownDestructuringErrors = false\n  if (!refDestructuringErrors) {\n    refDestructuringErrors = new DestructuringErrors\n    ownDestructuringErrors = true\n  }\n  let startPos = this.start, startLoc = this.startLoc\n  if (this.type == tt.parenL || this.type == tt.name)\n    this.potentialArrowAt = this.start\n  let left = this.parseMaybeConditional(noIn, refDestructuringErrors)\n  if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc)\n  if (this.type.isAssign) {\n    this.checkPatternErrors(refDestructuringErrors, true)\n    if (!ownDestructuringErrors) DestructuringErrors.call(refDestructuringErrors)\n    let node = this.startNodeAt(startPos, startLoc)\n    node.operator = this.value\n    node.left = this.type === tt.eq ? this.toAssignable(left) : left\n    refDestructuringErrors.shorthandAssign = 0 // reset because shorthand default was used correctly\n    this.checkLVal(left)\n    this.next()\n    node.right = this.parseMaybeAssign(noIn)\n    return this.finishNode(node, \"AssignmentExpression\")\n  } else {\n    if (ownDestructuringErrors) this.checkExpressionErrors(refDestructuringErrors, true)\n  }\n  return left\n}\n\n// Parse a ternary conditional (`?:`) operator.\n\npp.parseMaybeConditional = function(noIn, refDestructuringErrors) {\n  let startPos = this.start, startLoc = this.startLoc\n  let expr = this.parseExprOps(noIn, refDestructuringErrors)\n  if (this.checkExpressionErrors(refDestructuringErrors)) return expr\n  if (this.eat(tt.question)) {\n    let node = this.startNodeAt(startPos, startLoc)\n    node.test = expr\n    node.consequent = this.parseMaybeAssign()\n    this.expect(tt.colon)\n    node.alternate = this.parseMaybeAssign(noIn)\n    return this.finishNode(node, \"ConditionalExpression\")\n  }\n  return expr\n}\n\n// Start the precedence parser.\n\npp.parseExprOps = function(noIn, refDestructuringErrors) {\n  let startPos = this.start, startLoc = this.startLoc\n  let expr = this.parseMaybeUnary(refDestructuringErrors, false)\n  if (this.checkExpressionErrors(refDestructuringErrors)) return expr\n  return this.parseExprOp(expr, startPos, startLoc, -1, noIn)\n}\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\n\npp.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n  let prec = this.type.binop\n  if (prec != null && (!noIn || this.type !== tt._in)) {\n    if (prec > minPrec) {\n      let logical = this.type === tt.logicalOR || this.type === tt.logicalAND\n      let op = this.value\n      this.next()\n      let startPos = this.start, startLoc = this.startLoc\n      let right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn)\n      let node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical)\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)\n    }\n  }\n  return left\n}\n\npp.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n  let node = this.startNodeAt(startPos, startLoc)\n  node.left = left\n  node.operator = op\n  node.right = right\n  return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\")\n}\n\n// Parse unary operators, both prefix and postfix.\n\npp.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {\n  let startPos = this.start, startLoc = this.startLoc, expr\n  if (this.type.prefix) {\n    let node = this.startNode(), update = this.type === tt.incDec\n    node.operator = this.value\n    node.prefix = true\n    this.next()\n    node.argument = this.parseMaybeUnary(null, true)\n    this.checkExpressionErrors(refDestructuringErrors, true)\n    if (update) this.checkLVal(node.argument)\n    else if (this.strict && node.operator === \"delete\" &&\n             node.argument.type === \"Identifier\")\n      this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\")\n    else sawUnary = true\n    expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\")\n  } else {\n    expr = this.parseExprSubscripts(refDestructuringErrors)\n    if (this.checkExpressionErrors(refDestructuringErrors)) return expr\n    while (this.type.postfix && !this.canInsertSemicolon()) {\n      let node = this.startNodeAt(startPos, startLoc)\n      node.operator = this.value\n      node.prefix = false\n      node.argument = expr\n      this.checkLVal(expr)\n      this.next()\n      expr = this.finishNode(node, \"UpdateExpression\")\n    }\n  }\n\n  if (!sawUnary && this.eat(tt.starstar))\n    return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false)\n  else\n    return expr\n}\n\n// Parse call, dot, and `[]`-subscript expressions.\n\npp.parseExprSubscripts = function(refDestructuringErrors) {\n  let startPos = this.start, startLoc = this.startLoc\n  let expr = this.parseExprAtom(refDestructuringErrors)\n  let skipArrowSubscripts = expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\"\n  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) return expr\n  return this.parseSubscripts(expr, startPos, startLoc)\n}\n\npp.parseSubscripts = function(base, startPos, startLoc, noCalls) {\n  for (;;) {\n    if (this.eat(tt.dot)) {\n      let node = this.startNodeAt(startPos, startLoc)\n      node.object = base\n      node.property = this.parseIdent(true)\n      node.computed = false\n      base = this.finishNode(node, \"MemberExpression\")\n    } else if (this.eat(tt.bracketL)) {\n      let node = this.startNodeAt(startPos, startLoc)\n      node.object = base\n      node.property = this.parseExpression()\n      node.computed = true\n      this.expect(tt.bracketR)\n      base = this.finishNode(node, \"MemberExpression\")\n    } else if (!noCalls && this.eat(tt.parenL)) {\n      let node = this.startNodeAt(startPos, startLoc)\n      node.callee = base\n      node.arguments = this.parseExprList(tt.parenR, false)\n      base = this.finishNode(node, \"CallExpression\")\n    } else if (this.type === tt.backQuote) {\n      let node = this.startNodeAt(startPos, startLoc)\n      node.tag = base\n      node.quasi = this.parseTemplate()\n      base = this.finishNode(node, \"TaggedTemplateExpression\")\n    } else {\n      return base\n    }\n  }\n}\n\n// Parse an atomic expression — either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n\npp.parseExprAtom = function(refDestructuringErrors) {\n  let node, canBeArrow = this.potentialArrowAt == this.start\n  switch (this.type) {\n  case tt._super:\n    if (!this.inFunction)\n      this.raise(this.start, \"'super' outside of function or class\")\n\n  case tt._this:\n    let type = this.type === tt._this ? \"ThisExpression\" : \"Super\"\n    node = this.startNode()\n    this.next()\n    return this.finishNode(node, type)\n\n  case tt.name:\n    let startPos = this.start, startLoc = this.startLoc\n    let id = this.parseIdent(this.type !== tt.name)\n    if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow))\n      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id])\n    return id\n\n  case tt.regexp:\n    let value = this.value\n    node = this.parseLiteral(value.value)\n    node.regex = {pattern: value.pattern, flags: value.flags}\n    return node\n\n  case tt.num: case tt.string:\n    return this.parseLiteral(this.value)\n\n  case tt._null: case tt._true: case tt._false:\n    node = this.startNode()\n    node.value = this.type === tt._null ? null : this.type === tt._true\n    node.raw = this.type.keyword\n    this.next()\n    return this.finishNode(node, \"Literal\")\n\n  case tt.parenL:\n    return this.parseParenAndDistinguishExpression(canBeArrow)\n\n  case tt.bracketL:\n    node = this.startNode()\n    this.next()\n    node.elements = this.parseExprList(tt.bracketR, true, true, refDestructuringErrors)\n    return this.finishNode(node, \"ArrayExpression\")\n\n  case tt.braceL:\n    return this.parseObj(false, refDestructuringErrors)\n\n  case tt._function:\n    node = this.startNode()\n    this.next()\n    return this.parseFunction(node, false)\n\n  case tt._class:\n    return this.parseClass(this.startNode(), false)\n\n  case tt._new:\n    return this.parseNew()\n\n  case tt.backQuote:\n    return this.parseTemplate()\n\n  default:\n    this.unexpected()\n  }\n}\n\npp.parseLiteral = function(value) {\n  let node = this.startNode()\n  node.value = value\n  node.raw = this.input.slice(this.start, this.end)\n  this.next()\n  return this.finishNode(node, \"Literal\")\n}\n\npp.parseParenExpression = function() {\n  this.expect(tt.parenL)\n  let val = this.parseExpression()\n  this.expect(tt.parenR)\n  return val\n}\n\npp.parseParenAndDistinguishExpression = function(canBeArrow) {\n  let startPos = this.start, startLoc = this.startLoc, val\n  if (this.options.ecmaVersion >= 6) {\n    this.next()\n\n    let innerStartPos = this.start, innerStartLoc = this.startLoc\n    let exprList = [], first = true\n    let refDestructuringErrors = new DestructuringErrors, spreadStart, innerParenStart\n    while (this.type !== tt.parenR) {\n      first ? first = false : this.expect(tt.comma)\n      if (this.type === tt.ellipsis) {\n        spreadStart = this.start\n        exprList.push(this.parseParenItem(this.parseRest()))\n        break\n      } else {\n        if (this.type === tt.parenL && !innerParenStart) {\n          innerParenStart = this.start\n        }\n        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem))\n      }\n    }\n    let innerEndPos = this.start, innerEndLoc = this.startLoc\n    this.expect(tt.parenR)\n\n    if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow)) {\n      this.checkPatternErrors(refDestructuringErrors, true)\n      if (innerParenStart) this.unexpected(innerParenStart)\n      return this.parseParenArrowList(startPos, startLoc, exprList)\n    }\n\n    if (!exprList.length) this.unexpected(this.lastTokStart)\n    if (spreadStart) this.unexpected(spreadStart)\n    this.checkExpressionErrors(refDestructuringErrors, true)\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc)\n      val.expressions = exprList\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc)\n    } else {\n      val = exprList[0]\n    }\n  } else {\n    val = this.parseParenExpression()\n  }\n\n  if (this.options.preserveParens) {\n    let par = this.startNodeAt(startPos, startLoc)\n    par.expression = val\n    return this.finishNode(par, \"ParenthesizedExpression\")\n  } else {\n    return val\n  }\n}\n\npp.parseParenItem = function(item) {\n  return item\n}\n\npp.parseParenArrowList = function(startPos, startLoc, exprList) {\n  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)\n}\n\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call — at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\n\nconst empty = []\n\npp.parseNew = function() {\n  let node = this.startNode()\n  let meta = this.parseIdent(true)\n  if (this.options.ecmaVersion >= 6 && this.eat(tt.dot)) {\n    node.meta = meta\n    node.property = this.parseIdent(true)\n    if (node.property.name !== \"target\")\n      this.raiseRecoverable(node.property.start, \"The only valid meta property for new is new.target\")\n    if (!this.inFunction)\n      this.raiseRecoverable(node.start, \"new.target can only be used in functions\")\n    return this.finishNode(node, \"MetaProperty\")\n  }\n  let startPos = this.start, startLoc = this.startLoc\n  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true)\n  if (this.eat(tt.parenL)) node.arguments = this.parseExprList(tt.parenR, false)\n  else node.arguments = empty\n  return this.finishNode(node, \"NewExpression\")\n}\n\n// Parse template expression.\n\npp.parseTemplateElement = function() {\n  let elem = this.startNode()\n  elem.value = {\n    raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, '\\n'),\n    cooked: this.value\n  }\n  this.next()\n  elem.tail = this.type === tt.backQuote\n  return this.finishNode(elem, \"TemplateElement\")\n}\n\npp.parseTemplate = function() {\n  let node = this.startNode()\n  this.next()\n  node.expressions = []\n  let curElt = this.parseTemplateElement()\n  node.quasis = [curElt]\n  while (!curElt.tail) {\n    this.expect(tt.dollarBraceL)\n    node.expressions.push(this.parseExpression())\n    this.expect(tt.braceR)\n    node.quasis.push(curElt = this.parseTemplateElement())\n  }\n  this.next()\n  return this.finishNode(node, \"TemplateLiteral\")\n}\n\n// Parse an object literal or binding pattern.\n\npp.parseObj = function(isPattern, refDestructuringErrors) {\n  let node = this.startNode(), first = true, propHash = {}\n  node.properties = []\n  this.next()\n  while (!this.eat(tt.braceR)) {\n    if (!first) {\n      this.expect(tt.comma)\n      if (this.afterTrailingComma(tt.braceR)) break\n    } else first = false\n\n    let prop = this.startNode(), isGenerator, startPos, startLoc\n    if (this.options.ecmaVersion >= 6) {\n      prop.method = false\n      prop.shorthand = false\n      if (isPattern || refDestructuringErrors) {\n        startPos = this.start\n        startLoc = this.startLoc\n      }\n      if (!isPattern)\n        isGenerator = this.eat(tt.star)\n    }\n    this.parsePropertyName(prop)\n    this.parsePropertyValue(prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors)\n    this.checkPropClash(prop, propHash)\n    node.properties.push(this.finishNode(prop, \"Property\"))\n  }\n  return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\n}\n\npp.parsePropertyValue = function(prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors) {\n  if (this.eat(tt.colon)) {\n    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors)\n    prop.kind = \"init\"\n  } else if (this.options.ecmaVersion >= 6 && this.type === tt.parenL) {\n    if (isPattern) this.unexpected()\n    prop.kind = \"init\"\n    prop.method = true\n    prop.value = this.parseMethod(isGenerator)\n  } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\n             (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n             (this.type != tt.comma && this.type != tt.braceR)) {\n    if (isGenerator || isPattern) this.unexpected()\n    prop.kind = prop.key.name\n    this.parsePropertyName(prop)\n    prop.value = this.parseMethod(false)\n    let paramCount = prop.kind === \"get\" ? 0 : 1\n    if (prop.value.params.length !== paramCount) {\n      let start = prop.value.start\n      if (prop.kind === \"get\")\n        this.raiseRecoverable(start, \"getter should have no params\")\n      else\n        this.raiseRecoverable(start, \"setter should have exactly one param\")\n    }\n    if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\n      this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\")\n  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n    if (this.keywords.test(prop.key.name) ||\n        (this.strict ? this.reservedWordsStrictBind : this.reservedWords).test(prop.key.name) ||\n        (this.inGenerator && prop.key.name == \"yield\"))\n      this.raiseRecoverable(prop.key.start, \"'\" + prop.key.name + \"' can not be used as shorthand property\")\n    prop.kind = \"init\"\n    if (isPattern) {\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)\n    } else if (this.type === tt.eq && refDestructuringErrors) {\n      if (!refDestructuringErrors.shorthandAssign)\n        refDestructuringErrors.shorthandAssign = this.start\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)\n    } else {\n      prop.value = prop.key\n    }\n    prop.shorthand = true\n  } else this.unexpected()\n}\n\npp.parsePropertyName = function(prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(tt.bracketL)) {\n      prop.computed = true\n      prop.key = this.parseMaybeAssign()\n      this.expect(tt.bracketR)\n      return prop.key\n    } else {\n      prop.computed = false\n    }\n  }\n  return prop.key = this.type === tt.num || this.type === tt.string ? this.parseExprAtom() : this.parseIdent(true)\n}\n\n// Initialize empty function node.\n\npp.initFunction = function(node) {\n  node.id = null\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = false\n    node.expression = false\n  }\n}\n\n// Parse object or class method.\n\npp.parseMethod = function(isGenerator) {\n  let node = this.startNode(), oldInGen = this.inGenerator\n  this.inGenerator = isGenerator\n  this.initFunction(node)\n  this.expect(tt.parenL)\n  node.params = this.parseBindingList(tt.parenR, false, false)\n  if (this.options.ecmaVersion >= 6)\n    node.generator = isGenerator\n  this.parseFunctionBody(node, false)\n  this.inGenerator = oldInGen\n  return this.finishNode(node, \"FunctionExpression\")\n}\n\n// Parse arrow function expression with given parameters.\n\npp.parseArrowExpression = function(node, params) {\n  let oldInGen = this.inGenerator\n  this.inGenerator = false\n  this.initFunction(node)\n  node.params = this.toAssignableList(params, true)\n  this.parseFunctionBody(node, true)\n  this.inGenerator = oldInGen\n  return this.finishNode(node, \"ArrowFunctionExpression\")\n}\n\n// Parse function body and check parameters.\n\npp.parseFunctionBody = function(node, isArrowFunction) {\n  let isExpression = isArrowFunction && this.type !== tt.braceL\n\n  if (isExpression) {\n    node.body = this.parseMaybeAssign()\n    node.expression = true\n  } else {\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    let oldInFunc = this.inFunction, oldLabels = this.labels\n    this.inFunction = true; this.labels = []\n    node.body = this.parseBlock(true)\n    node.expression = false\n    this.inFunction = oldInFunc; this.labels = oldLabels\n  }\n\n  // If this is a strict mode function, verify that argument names\n  // are not repeated, and it does not try to bind the words `eval`\n  // or `arguments`.\n  let useStrict = (!isExpression && node.body.body.length && this.isUseStrict(node.body.body[0])) ? node.body.body[0] : null;\n  if (this.strict || useStrict) {\n    let oldStrict = this.strict\n    this.strict = true\n    if (node.id)\n      this.checkLVal(node.id, true)\n    this.checkParams(node, useStrict)\n    this.strict = oldStrict\n  } else if (isArrowFunction) {\n    this.checkParams(node, useStrict)\n  }\n}\n\n// Checks function params for various disallowed patterns such as using \"eval\"\n// or \"arguments\" and duplicate parameters.\n\npp.checkParams = function(node, useStrict) {\n    let nameHash = {}\n    for (let i = 0; i < node.params.length; i++) {\n      if (useStrict && this.options.ecmaVersion >= 7 && node.params[i].type !== \"Identifier\")\n        this.raiseRecoverable(useStrict.start, \"Illegal 'use strict' directive in function with non-simple parameter list\");\n      this.checkLVal(node.params[i], true, nameHash)\n    }\n}\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\npp.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n  let elts = [], first = true\n  while (!this.eat(close)) {\n    if (!first) {\n      this.expect(tt.comma)\n      if (allowTrailingComma && this.afterTrailingComma(close)) break\n    } else first = false\n\n    let elt\n    if (allowEmpty && this.type === tt.comma)\n      elt = null\n    else if (this.type === tt.ellipsis) {\n      elt = this.parseSpread(refDestructuringErrors)\n      if (this.type === tt.comma && refDestructuringErrors && !refDestructuringErrors.trailingComma) {\n        refDestructuringErrors.trailingComma = this.lastTokStart\n      }\n    } else\n      elt = this.parseMaybeAssign(false, refDestructuringErrors)\n    elts.push(elt)\n  }\n  return elts\n}\n\n// Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\n\npp.parseIdent = function(liberal) {\n  let node = this.startNode()\n  if (liberal && this.options.allowReserved == \"never\") liberal = false\n  if (this.type === tt.name) {\n    if (!liberal && (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) &&\n        (this.options.ecmaVersion >= 6 ||\n         this.input.slice(this.start, this.end).indexOf(\"\\\\\") == -1))\n      this.raiseRecoverable(this.start, \"The keyword '\" + this.value + \"' is reserved\")\n    if (!liberal && this.inGenerator && this.value === \"yield\")\n      this.raiseRecoverable(this.start, \"Can not use 'yield' as identifier inside a generator\")\n    node.name = this.value\n  } else if (liberal && this.type.keyword) {\n    node.name = this.type.keyword\n  } else {\n    this.unexpected()\n  }\n  this.next()\n  return this.finishNode(node, \"Identifier\")\n}\n\n// Parses yield expression inside generator.\n\npp.parseYield = function() {\n  let node = this.startNode()\n  this.next()\n  if (this.type == tt.semi || this.canInsertSemicolon() || (this.type != tt.star && !this.type.startsExpr)) {\n    node.delegate = false\n    node.argument = null\n  } else {\n    node.delegate = this.eat(tt.star)\n    node.argument = this.parseMaybeAssign()\n  }\n  return this.finishNode(node, \"YieldExpression\")\n}\n"]}