{"version":3,"sources":["../../../../../../node_modules/acorn-jsx/node_modules/acorn/src/lval.js"],"names":["pp","prototype","toAssignable","node","isBinding","options","ecmaVersion","type","i","properties","length","prop","kind","raise","key","start","value","toAssignableList","elements","operator","left","end","right","expression","exprList","last","arg","argument","unexpected","elt","parseSpread","refDestructuringErrors","startNode","next","parseMaybeAssign","finishNode","parseRest","allowNonIdent","name","parseIdent","bracketL","parseBindingAtom","parseBindingList","bracketR","braceL","parseObj","close","allowEmpty","allowTrailingComma","elts","first","eat","expect","comma","push","afterTrailingComma","ellipsis","rest","parseBindingListItem","elem","parseMaybeDefault","startLoc","param","startPos","eq","startNodeAt","checkLVal","expr","checkClashes","strict","reservedWordsStrictBind","test","raiseRecoverable"],"mappings":";;AAAA;;AACA;;AACA;;AAEA,IAAMA,KAAK,cAAOC,SAAlB;;AAEA;AACA;;AAEAD,GAAGE,YAAH,GAAkB,UAASC,IAAT,EAAeC,SAAf,EAA0B;AAC1C,MAAI,KAAKC,OAAL,CAAaC,WAAb,IAA4B,CAA5B,IAAiCH,IAArC,EAA2C;AACzC,YAAQA,KAAKI,IAAb;AACA,WAAK,YAAL;AACA,WAAK,eAAL;AACA,WAAK,cAAL;AACE;;AAEF,WAAK,kBAAL;AACEJ,aAAKI,IAAL,GAAY,eAAZ;AACA,aAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIL,KAAKM,UAAL,CAAgBC,MAApC,EAA4CF,GAA5C,EAAiD;AAC/C,cAAIG,OAAOR,KAAKM,UAAL,CAAgBD,CAAhB,CAAX;AACA,cAAIG,KAAKC,IAAL,KAAc,MAAlB,EAA0B,KAAKC,KAAL,CAAWF,KAAKG,GAAL,CAASC,KAApB,EAA2B,+CAA3B;AAC1B,eAAKb,YAAL,CAAkBS,KAAKK,KAAvB,EAA8BZ,SAA9B;AACD;AACD;;AAEF,WAAK,iBAAL;AACED,aAAKI,IAAL,GAAY,cAAZ;AACA,aAAKU,gBAAL,CAAsBd,KAAKe,QAA3B,EAAqCd,SAArC;AACA;;AAEF,WAAK,sBAAL;AACE,YAAID,KAAKgB,QAAL,KAAkB,GAAtB,EAA2B;AACzBhB,eAAKI,IAAL,GAAY,mBAAZ;AACA,iBAAOJ,KAAKgB,QAAZ;AACA;AACD,SAJD,MAIO;AACL,eAAKN,KAAL,CAAWV,KAAKiB,IAAL,CAAUC,GAArB,EAA0B,6DAA1B;AACA;AACD;;AAEH,WAAK,mBAAL;AACE,YAAIlB,KAAKmB,KAAL,CAAWf,IAAX,KAAoB,iBAAxB,EACE,KAAKM,KAAL,CAAWV,KAAKmB,KAAL,CAAWP,KAAtB,EAA6B,4CAA7B;AACF;;AAEF,WAAK,yBAAL;AACEZ,aAAKoB,UAAL,GAAkB,KAAKrB,YAAL,CAAkBC,KAAKoB,UAAvB,EAAmCnB,SAAnC,CAAlB;AACA;;AAEF,WAAK,kBAAL;AACE,YAAI,CAACA,SAAL,EAAgB;;AAElB;AACE,aAAKS,KAAL,CAAWV,KAAKY,KAAhB,EAAuB,qBAAvB;AA3CF;AA6CD;AACD,SAAOZ,IAAP;AACD,CAjDD;;AAmDA;;AAEAH,GAAGiB,gBAAH,GAAsB,UAASO,QAAT,EAAmBpB,SAAnB,EAA8B;AAClD,MAAIiB,MAAMG,SAASd,MAAnB;AACA,MAAIW,GAAJ,EAAS;AACP,QAAII,OAAOD,SAASH,MAAM,CAAf,CAAX;AACA,QAAII,QAAQA,KAAKlB,IAAL,IAAa,aAAzB,EAAwC;AACtC,QAAEc,GAAF;AACD,KAFD,MAEO,IAAII,QAAQA,KAAKlB,IAAL,IAAa,eAAzB,EAA0C;AAC/CkB,WAAKlB,IAAL,GAAY,aAAZ;AACA,UAAImB,MAAMD,KAAKE,QAAf;AACA,WAAKzB,YAAL,CAAkBwB,GAAlB,EAAuBtB,SAAvB;AACA,UAAIsB,IAAInB,IAAJ,KAAa,YAAb,IAA6BmB,IAAInB,IAAJ,KAAa,kBAA1C,IAAgEmB,IAAInB,IAAJ,KAAa,cAAjF,EACE,KAAKqB,UAAL,CAAgBF,IAAIX,KAApB;AACF,QAAEM,GAAF;AACD;;AAED,QAAIjB,aAAaqB,IAAb,IAAqBA,KAAKlB,IAAL,KAAc,aAAnC,IAAoDkB,KAAKE,QAAL,CAAcpB,IAAd,KAAuB,YAA/E,EACE,KAAKqB,UAAL,CAAgBH,KAAKE,QAAL,CAAcZ,KAA9B;AACH;AACD,OAAK,IAAIP,IAAI,CAAb,EAAgBA,IAAIa,GAApB,EAAyBb,GAAzB,EAA8B;AAC5B,QAAIqB,MAAML,SAAShB,CAAT,CAAV;AACA,QAAIqB,GAAJ,EAAS,KAAK3B,YAAL,CAAkB2B,GAAlB,EAAuBzB,SAAvB;AACV;AACD,SAAOoB,QAAP;AACD,CAvBD;;AAyBA;;AAEAxB,GAAG8B,WAAH,GAAiB,UAASC,sBAAT,EAAiC;AAChD,MAAI5B,OAAO,KAAK6B,SAAL,EAAX;AACA,OAAKC,IAAL;AACA9B,OAAKwB,QAAL,GAAgB,KAAKO,gBAAL,CAAsB,KAAtB,EAA6BH,sBAA7B,CAAhB;AACA,SAAO,KAAKI,UAAL,CAAgBhC,IAAhB,EAAsB,eAAtB,CAAP;AACD,CALD;;AAOAH,GAAGoC,SAAH,GAAe,UAASC,aAAT,EAAwB;AACrC,MAAIlC,OAAO,KAAK6B,SAAL,EAAX;AACA,OAAKC;;AAEL;AAFA,KAGA,IAAII,aAAJ,EAAmBlC,KAAKwB,QAAL,GAAgB,KAAKpB,IAAL,KAAc,iBAAG+B,IAAjB,GAAwB,KAAKC,UAAL,EAAxB,GAA4C,KAAKX,UAAL,EAA5D,CAAnB,KACKzB,KAAKwB,QAAL,GAAgB,KAAKpB,IAAL,KAAc,iBAAG+B,IAAjB,IAAyB,KAAK/B,IAAL,KAAc,iBAAGiC,QAA1C,GAAqD,KAAKC,gBAAL,EAArD,GAA+E,KAAKb,UAAL,EAA/F;;AAEL,SAAO,KAAKO,UAAL,CAAgBhC,IAAhB,EAAsB,aAAtB,CAAP;AACD,CATD;;AAWA;;AAEAH,GAAGyC,gBAAH,GAAsB,YAAW;AAC/B,MAAI,KAAKpC,OAAL,CAAaC,WAAb,GAA2B,CAA/B,EAAkC,OAAO,KAAKiC,UAAL,EAAP;AAClC,UAAQ,KAAKhC,IAAb;AACA,SAAK,iBAAG+B,IAAR;AACE,aAAO,KAAKC,UAAL,EAAP;;AAEF,SAAK,iBAAGC,QAAR;AACE,UAAIrC,OAAO,KAAK6B,SAAL,EAAX;AACA,WAAKC,IAAL;AACA9B,WAAKe,QAAL,GAAgB,KAAKwB,gBAAL,CAAsB,iBAAGC,QAAzB,EAAmC,IAAnC,EAAyC,IAAzC,CAAhB;AACA,aAAO,KAAKR,UAAL,CAAgBhC,IAAhB,EAAsB,cAAtB,CAAP;;AAEF,SAAK,iBAAGyC,MAAR;AACE,aAAO,KAAKC,QAAL,CAAc,IAAd,CAAP;;AAEF;AACE,WAAKjB,UAAL;AAdF;AAgBD,CAlBD;;AAoBA5B,GAAG0C,gBAAH,GAAsB,UAASI,KAAT,EAAgBC,UAAhB,EAA4BC,kBAA5B,EAAgDX,aAAhD,EAA+D;AACnF,MAAIY,OAAO,EAAX;AAAA,MAAeC,QAAQ,IAAvB;AACA,SAAO,CAAC,KAAKC,GAAL,CAASL,KAAT,CAAR,EAAyB;AACvB,QAAII,KAAJ,EAAWA,QAAQ,KAAR,CAAX,KACK,KAAKE,MAAL,CAAY,iBAAGC,KAAf;AACL,QAAIN,cAAc,KAAKxC,IAAL,KAAc,iBAAG8C,KAAnC,EAA0C;AACxCJ,WAAKK,IAAL,CAAU,IAAV;AACD,KAFD,MAEO,IAAIN,sBAAsB,KAAKO,kBAAL,CAAwBT,KAAxB,CAA1B,EAA0D;AAC/D;AACD,KAFM,MAEA,IAAI,KAAKvC,IAAL,KAAc,iBAAGiD,QAArB,EAA+B;AACpC,UAAIC,OAAO,KAAKrB,SAAL,CAAeC,aAAf,CAAX;AACA,WAAKqB,oBAAL,CAA0BD,IAA1B;AACAR,WAAKK,IAAL,CAAUG,IAAV;AACA,UAAI,KAAKlD,IAAL,KAAc,iBAAG8C,KAArB,EAA4B,KAAKxC,KAAL,CAAW,KAAKE,KAAhB,EAAuB,+CAAvB;AAC5B,WAAKqC,MAAL,CAAYN,KAAZ;AACA;AACD,KAPM,MAOA;AACL,UAAIa,OAAO,KAAKC,iBAAL,CAAuB,KAAK7C,KAA5B,EAAmC,KAAK8C,QAAxC,CAAX;AACA,WAAKH,oBAAL,CAA0BC,IAA1B;AACAV,WAAKK,IAAL,CAAUK,IAAV;AACD;AACF;AACD,SAAOV,IAAP;AACD,CAvBD;;AAyBAjD,GAAG0D,oBAAH,GAA0B,UAASI,KAAT,EAAgB;AACxC,SAAOA,KAAP;AACD,CAFD;;AAIA;;AAEA9D,GAAG4D,iBAAH,GAAuB,UAASG,QAAT,EAAmBF,QAAnB,EAA6BzC,IAA7B,EAAmC;AACxDA,SAAOA,QAAQ,KAAKqB,gBAAL,EAAf;AACA,MAAI,KAAKpC,OAAL,CAAaC,WAAb,GAA2B,CAA3B,IAAgC,CAAC,KAAK6C,GAAL,CAAS,iBAAGa,EAAZ,CAArC,EAAsD,OAAO5C,IAAP;AACtD,MAAIjB,OAAO,KAAK8D,WAAL,CAAiBF,QAAjB,EAA2BF,QAA3B,CAAX;AACA1D,OAAKiB,IAAL,GAAYA,IAAZ;AACAjB,OAAKmB,KAAL,GAAa,KAAKY,gBAAL,EAAb;AACA,SAAO,KAAKC,UAAL,CAAgBhC,IAAhB,EAAsB,mBAAtB,CAAP;AACD,CAPD;;AASA;AACA;;AAEAH,GAAGkE,SAAH,GAAe,UAASC,IAAT,EAAe/D,SAAf,EAA0BgE,YAA1B,EAAwC;AACrD,UAAQD,KAAK5D,IAAb;AACA,SAAK,YAAL;AACE,UAAI,KAAK8D,MAAL,IAAe,KAAKC,uBAAL,CAA6BC,IAA7B,CAAkCJ,KAAK7B,IAAvC,CAAnB,EACE,KAAKkC,gBAAL,CAAsBL,KAAKpD,KAA3B,EAAkC,CAACX,YAAY,UAAZ,GAAyB,eAA1B,IAA6C+D,KAAK7B,IAAlD,GAAyD,iBAA3F;AACF,UAAI8B,YAAJ,EAAkB;AAChB,YAAI,eAAIA,YAAJ,EAAkBD,KAAK7B,IAAvB,CAAJ,EACE,KAAKkC,gBAAL,CAAsBL,KAAKpD,KAA3B,EAAkC,qBAAlC;AACFqD,qBAAaD,KAAK7B,IAAlB,IAA0B,IAA1B;AACD;AACD;;AAEF,SAAK,kBAAL;AACE,UAAIlC,SAAJ,EAAe,KAAKoE,gBAAL,CAAsBL,KAAKpD,KAA3B,EAAkC,CAACX,YAAY,SAAZ,GAAwB,cAAzB,IAA2C,oBAA7E;AACf;;AAEF,SAAK,eAAL;AACE,WAAK,IAAII,IAAI,CAAb,EAAgBA,IAAI2D,KAAK1D,UAAL,CAAgBC,MAApC,EAA4CF,GAA5C;AACE,aAAK0D,SAAL,CAAeC,KAAK1D,UAAL,CAAgBD,CAAhB,EAAmBQ,KAAlC,EAAyCZ,SAAzC,EAAoDgE,YAApD;AADF,OAEA;;AAEF,SAAK,cAAL;AACE,WAAK,IAAI5D,KAAI,CAAb,EAAgBA,KAAI2D,KAAKjD,QAAL,CAAcR,MAAlC,EAA0CF,IAA1C,EAA+C;AAC7C,YAAImD,OAAOQ,KAAKjD,QAAL,CAAcV,EAAd,CAAX;AACA,YAAImD,IAAJ,EAAU,KAAKO,SAAL,CAAeP,IAAf,EAAqBvD,SAArB,EAAgCgE,YAAhC;AACX;AACD;;AAEF,SAAK,mBAAL;AACE,WAAKF,SAAL,CAAeC,KAAK/C,IAApB,EAA0BhB,SAA1B,EAAqCgE,YAArC;AACA;;AAEF,SAAK,aAAL;AACE,WAAKF,SAAL,CAAeC,KAAKxC,QAApB,EAA8BvB,SAA9B,EAAyCgE,YAAzC;AACA;;AAEF,SAAK,yBAAL;AACE,WAAKF,SAAL,CAAeC,KAAK5C,UAApB,EAAgCnB,SAAhC,EAA2CgE,YAA3C;AACA;;AAEF;AACE,WAAKvD,KAAL,CAAWsD,KAAKpD,KAAhB,EAAuB,CAACX,YAAY,SAAZ,GAAwB,cAAzB,IAA2C,SAAlE;AAxCF;AA0CD,CA3CD","file":"lval.js","sourcesContent":["import {types as tt} from \"./tokentype\"\nimport {Parser} from \"./state\"\nimport {has} from \"./util\"\n\nconst pp = Parser.prototype\n\n// Convert existing expression atom to assignable pattern\n// if possible.\n\npp.toAssignable = function(node, isBinding) {\n  if (this.options.ecmaVersion >= 6 && node) {\n    switch (node.type) {\n    case \"Identifier\":\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n      break\n\n    case \"ObjectExpression\":\n      node.type = \"ObjectPattern\"\n      for (let i = 0; i < node.properties.length; i++) {\n        let prop = node.properties[i]\n        if (prop.kind !== \"init\") this.raise(prop.key.start, \"Object pattern can't contain getter or setter\")\n        this.toAssignable(prop.value, isBinding)\n      }\n      break\n\n    case \"ArrayExpression\":\n      node.type = \"ArrayPattern\"\n      this.toAssignableList(node.elements, isBinding)\n      break\n\n    case \"AssignmentExpression\":\n      if (node.operator === \"=\") {\n        node.type = \"AssignmentPattern\"\n        delete node.operator\n        // falls through to AssignmentPattern\n      } else {\n        this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\")\n        break\n      }\n\n    case \"AssignmentPattern\":\n      if (node.right.type === \"YieldExpression\")\n        this.raise(node.right.start, \"Yield expression cannot be a default value\")\n      break\n\n    case \"ParenthesizedExpression\":\n      node.expression = this.toAssignable(node.expression, isBinding)\n      break\n\n    case \"MemberExpression\":\n      if (!isBinding) break\n\n    default:\n      this.raise(node.start, \"Assigning to rvalue\")\n    }\n  }\n  return node\n}\n\n// Convert list of expression atoms to binding list.\n\npp.toAssignableList = function(exprList, isBinding) {\n  let end = exprList.length\n  if (end) {\n    let last = exprList[end - 1]\n    if (last && last.type == \"RestElement\") {\n      --end\n    } else if (last && last.type == \"SpreadElement\") {\n      last.type = \"RestElement\"\n      let arg = last.argument\n      this.toAssignable(arg, isBinding)\n      if (arg.type !== \"Identifier\" && arg.type !== \"MemberExpression\" && arg.type !== \"ArrayPattern\")\n        this.unexpected(arg.start)\n      --end\n    }\n\n    if (isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\n      this.unexpected(last.argument.start)\n  }\n  for (let i = 0; i < end; i++) {\n    let elt = exprList[i]\n    if (elt) this.toAssignable(elt, isBinding)\n  }\n  return exprList\n}\n\n// Parses spread element.\n\npp.parseSpread = function(refDestructuringErrors) {\n  let node = this.startNode()\n  this.next()\n  node.argument = this.parseMaybeAssign(false, refDestructuringErrors)\n  return this.finishNode(node, \"SpreadElement\")\n}\n\npp.parseRest = function(allowNonIdent) {\n  let node = this.startNode()\n  this.next()\n\n  // RestElement inside of a function parameter must be an identifier\n  if (allowNonIdent) node.argument = this.type === tt.name ? this.parseIdent() : this.unexpected()\n  else node.argument = this.type === tt.name || this.type === tt.bracketL ? this.parseBindingAtom() : this.unexpected()\n\n  return this.finishNode(node, \"RestElement\")\n}\n\n// Parses lvalue (assignable) atom.\n\npp.parseBindingAtom = function() {\n  if (this.options.ecmaVersion < 6) return this.parseIdent()\n  switch (this.type) {\n  case tt.name:\n    return this.parseIdent()\n\n  case tt.bracketL:\n    let node = this.startNode()\n    this.next()\n    node.elements = this.parseBindingList(tt.bracketR, true, true)\n    return this.finishNode(node, \"ArrayPattern\")\n\n  case tt.braceL:\n    return this.parseObj(true)\n\n  default:\n    this.unexpected()\n  }\n}\n\npp.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowNonIdent) {\n  let elts = [], first = true\n  while (!this.eat(close)) {\n    if (first) first = false\n    else this.expect(tt.comma)\n    if (allowEmpty && this.type === tt.comma) {\n      elts.push(null)\n    } else if (allowTrailingComma && this.afterTrailingComma(close)) {\n      break\n    } else if (this.type === tt.ellipsis) {\n      let rest = this.parseRest(allowNonIdent)\n      this.parseBindingListItem(rest)\n      elts.push(rest)\n      if (this.type === tt.comma) this.raise(this.start, \"Comma is not permitted after the rest element\")\n      this.expect(close)\n      break\n    } else {\n      let elem = this.parseMaybeDefault(this.start, this.startLoc)\n      this.parseBindingListItem(elem)\n      elts.push(elem)\n    }\n  }\n  return elts\n}\n\npp.parseBindingListItem = function(param) {\n  return param\n}\n\n// Parses assignment pattern around given atom if possible.\n\npp.parseMaybeDefault = function(startPos, startLoc, left) {\n  left = left || this.parseBindingAtom()\n  if (this.options.ecmaVersion < 6 || !this.eat(tt.eq)) return left\n  let node = this.startNodeAt(startPos, startLoc)\n  node.left = left\n  node.right = this.parseMaybeAssign()\n  return this.finishNode(node, \"AssignmentPattern\")\n}\n\n// Verify that a node is an lval — something that can be assigned\n// to.\n\npp.checkLVal = function(expr, isBinding, checkClashes) {\n  switch (expr.type) {\n  case \"Identifier\":\n    if (this.strict && this.reservedWordsStrictBind.test(expr.name))\n      this.raiseRecoverable(expr.start, (isBinding ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\")\n    if (checkClashes) {\n      if (has(checkClashes, expr.name))\n        this.raiseRecoverable(expr.start, \"Argument name clash\")\n      checkClashes[expr.name] = true\n    }\n    break\n\n  case \"MemberExpression\":\n    if (isBinding) this.raiseRecoverable(expr.start, (isBinding ? \"Binding\" : \"Assigning to\") + \" member expression\")\n    break\n\n  case \"ObjectPattern\":\n    for (let i = 0; i < expr.properties.length; i++)\n      this.checkLVal(expr.properties[i].value, isBinding, checkClashes)\n    break\n\n  case \"ArrayPattern\":\n    for (let i = 0; i < expr.elements.length; i++) {\n      let elem = expr.elements[i]\n      if (elem) this.checkLVal(elem, isBinding, checkClashes)\n    }\n    break\n\n  case \"AssignmentPattern\":\n    this.checkLVal(expr.left, isBinding, checkClashes)\n    break\n\n  case \"RestElement\":\n    this.checkLVal(expr.argument, isBinding, checkClashes)\n    break\n\n  case \"ParenthesizedExpression\":\n    this.checkLVal(expr.expression, isBinding, checkClashes)\n    break\n\n  default:\n    this.raise(expr.start, (isBinding ? \"Binding\" : \"Assigning to\") + \" rvalue\")\n  }\n}\n"]}