{"version":3,"sources":["../../../../node_modules/acorn/src/statement.js"],"names":["pp","prototype","parseTopLevel","node","exports","body","type","eof","stmt","parseStatement","push","next","options","ecmaVersion","sourceType","finishNode","loopLabel","kind","switchLabel","isLet","name","value","lastIndex","pos","skip","exec","input","length","nextCh","charCodeAt","ident","slice","isKeyword","isAsyncFunction","test","charAt","declaration","topLevel","starttype","startNode","_var","_break","_continue","parseBreakContinueStatement","keyword","_debugger","parseDebuggerStatement","_do","parseDoStatement","_for","parseForStatement","_function","unexpected","parseFunctionStatement","_class","parseClass","_if","parseIfStatement","_return","parseReturnStatement","_switch","parseSwitchStatement","_throw","parseThrowStatement","_try","parseTryStatement","_const","parseVarStatement","_while","parseWhileStatement","_with","parseWithStatement","braceL","parseBlock","semi","parseEmptyStatement","_export","_import","allowImportExportEverywhere","raise","start","inModule","parseImport","parseExport","maybeName","expr","parseExpression","eat","colon","parseLabeledStatement","parseExpressionStatement","isBreak","insertSemicolon","label","parseIdent","semicolon","i","labels","lab","pop","expect","parseParenExpression","enterLexicalScope","parenL","parseFor","init","parseVar","_in","isContextual","declarations","parseForIn","refDestructuringErrors","toAssignable","checkLVal","checkPatternErrors","checkExpressionErrors","isAsync","parseFunction","isFunction","consequent","strict","alternate","_else","inFunction","allowReturnOutsideFunction","argument","discriminant","cases","cur","sawDefault","braceR","_case","_default","isCase","raiseRecoverable","lastTokStart","exitLexicalScope","lastTokEnd","empty","block","handler","_catch","clause","param","parseBindingAtom","parenR","finalizer","_finally","object","isLoop","statementStart","generator","expression","createNewLexicalScope","update","left","right","isFor","decl","parseVarId","eq","parseMaybeAssign","id","comma","isStatement","allowExpressionBody","initFunction","star","async","oldInGen","inGenerator","oldInAsync","inAsync","oldYieldPos","yieldPos","oldAwaitPos","awaitPos","oldInFunc","enterFunctionScope","parseFunctionParams","parseFunctionBody","params","parseBindingList","checkYieldAwaitInDefaultParams","parseClassId","parseClassSuper","classBody","hadConstructor","method","isGenerator","isMaybeStatic","parsePropertyName","static","computed","key","canInsertSemicolon","isGetSet","parseClassMethod","paramCount","parseMethod","superClass","_extends","parseExprSubscripts","expectContextual","source","string","parseExprAtom","checkExport","fNode","cNode","shouldParseExportStatement","checkVariableExport","specifiers","parseExportSpecifiers","eatContextual","keywords","local","reservedWords","checkPatternExport","pat","properties","elements","elt","decls","nodes","first","afterTrailingComma","exported","parseImportSpecifiers","imported","reservedWordsStrict"],"mappings":"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","file":"statement.js","sourcesContent":["import {types as tt} from \"./tokentype\"\nimport {Parser} from \"./state\"\nimport {lineBreak, skipWhiteSpace} from \"./whitespace\"\nimport {isIdentifierStart, isIdentifierChar} from \"./identifier\"\nimport {has} from \"./util\"\nimport {DestructuringErrors} from \"./parseutil\"\n\nconst pp = Parser.prototype\n\n// ### Statement parsing\n\n// Parse a program. Initializes the parser, reads any number of\n// statements, and wraps them in a Program node.  Optionally takes a\n// `program` argument.  If present, the statements will be appended\n// to its body instead of creating a new node.\n\npp.parseTopLevel = function(node) {\n  let exports = {}\n  if (!node.body) node.body = []\n  while (this.type !== tt.eof) {\n    let stmt = this.parseStatement(true, true, exports)\n    node.body.push(stmt)\n  }\n  this.next()\n  if (this.options.ecmaVersion >= 6) {\n    node.sourceType = this.options.sourceType\n  }\n  return this.finishNode(node, \"Program\")\n}\n\nconst loopLabel = {kind: \"loop\"}, switchLabel = {kind: \"switch\"}\n\npp.isLet = function() {\n  if (this.type !== tt.name || this.options.ecmaVersion < 6 || this.value != \"let\") return false\n  skipWhiteSpace.lastIndex = this.pos\n  let skip = skipWhiteSpace.exec(this.input)\n  let next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next)\n  if (nextCh === 91 || nextCh == 123) return true // '{' and '['\n  if (isIdentifierStart(nextCh, true)) {\n    let pos = next + 1\n    while (isIdentifierChar(this.input.charCodeAt(pos), true)) ++pos\n    let ident = this.input.slice(next, pos)\n    if (!this.isKeyword(ident)) return true\n  }\n  return false\n}\n\n// check 'async [no LineTerminator here] function'\n// - 'async /*foo*/ function' is OK.\n// - 'async /*\\n*/ function' is invalid.\npp.isAsyncFunction = function() {\n  if (this.type !== tt.name || this.options.ecmaVersion < 8 || this.value != \"async\")\n    return false\n\n  skipWhiteSpace.lastIndex = this.pos\n  let skip = skipWhiteSpace.exec(this.input)\n  let next = this.pos + skip[0].length\n  return !lineBreak.test(this.input.slice(this.pos, next)) &&\n    this.input.slice(next, next + 8) === \"function\" &&\n    (next + 8 == this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))\n}\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\npp.parseStatement = function(declaration, topLevel, exports) {\n  let starttype = this.type, node = this.startNode(), kind\n\n  if (this.isLet()) {\n    starttype = tt._var\n    kind = \"let\"\n  }\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n  case tt._break: case tt._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\n  case tt._debugger: return this.parseDebuggerStatement(node)\n  case tt._do: return this.parseDoStatement(node)\n  case tt._for: return this.parseForStatement(node)\n  case tt._function:\n    if (!declaration && this.options.ecmaVersion >= 6) this.unexpected()\n    return this.parseFunctionStatement(node, false)\n  case tt._class:\n    if (!declaration) this.unexpected()\n    return this.parseClass(node, true)\n  case tt._if: return this.parseIfStatement(node)\n  case tt._return: return this.parseReturnStatement(node)\n  case tt._switch: return this.parseSwitchStatement(node)\n  case tt._throw: return this.parseThrowStatement(node)\n  case tt._try: return this.parseTryStatement(node)\n  case tt._const: case tt._var:\n    kind = kind || this.value\n    if (!declaration && kind != \"var\") this.unexpected()\n    return this.parseVarStatement(node, kind)\n  case tt._while: return this.parseWhileStatement(node)\n  case tt._with: return this.parseWithStatement(node)\n  case tt.braceL: return this.parseBlock()\n  case tt.semi: return this.parseEmptyStatement(node)\n  case tt._export:\n  case tt._import:\n    if (!this.options.allowImportExportEverywhere) {\n      if (!topLevel)\n        this.raise(this.start, \"'import' and 'export' may only appear at the top level\")\n      if (!this.inModule)\n        this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\")\n    }\n    return starttype === tt._import ? this.parseImport(node) : this.parseExport(node, exports)\n\n    // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n  default:\n    if (this.isAsyncFunction() && declaration) {\n      this.next()\n      return this.parseFunctionStatement(node, true)\n    }\n\n    let maybeName = this.value, expr = this.parseExpression()\n    if (starttype === tt.name && expr.type === \"Identifier\" && this.eat(tt.colon))\n      return this.parseLabeledStatement(node, maybeName, expr)\n    else return this.parseExpressionStatement(node, expr)\n  }\n}\n\npp.parseBreakContinueStatement = function(node, keyword) {\n  let isBreak = keyword == \"break\"\n  this.next()\n  if (this.eat(tt.semi) || this.insertSemicolon()) node.label = null\n  else if (this.type !== tt.name) this.unexpected()\n  else {\n    node.label = this.parseIdent()\n    this.semicolon()\n  }\n\n  // Verify that there is an actual destination to break or\n  // continue to.\n  let i = 0\n  for (; i < this.labels.length; ++i) {\n    let lab = this.labels[i]\n    if (node.label == null || lab.name === node.label.name) {\n      if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break\n      if (node.label && isBreak) break\n    }\n  }\n  if (i === this.labels.length) this.raise(node.start, \"Unsyntactic \" + keyword)\n  return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n}\n\npp.parseDebuggerStatement = function(node) {\n  this.next()\n  this.semicolon()\n  return this.finishNode(node, \"DebuggerStatement\")\n}\n\npp.parseDoStatement = function(node) {\n  this.next()\n  this.labels.push(loopLabel)\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  this.expect(tt._while)\n  node.test = this.parseParenExpression()\n  if (this.options.ecmaVersion >= 6)\n    this.eat(tt.semi)\n  else\n    this.semicolon()\n  return this.finishNode(node, \"DoWhileStatement\")\n}\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\n\npp.parseForStatement = function(node) {\n  this.next()\n  this.labels.push(loopLabel)\n  this.enterLexicalScope()\n  this.expect(tt.parenL)\n  if (this.type === tt.semi) return this.parseFor(node, null)\n  let isLet = this.isLet()\n  if (this.type === tt._var || this.type === tt._const || isLet) {\n    let init = this.startNode(), kind = isLet ? \"let\" : this.value\n    this.next()\n    this.parseVar(init, true, kind)\n    this.finishNode(init, \"VariableDeclaration\")\n    if ((this.type === tt._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init.declarations.length === 1 &&\n        !(kind !== \"var\" && init.declarations[0].init))\n      return this.parseForIn(node, init)\n    return this.parseFor(node, init)\n  }\n  let refDestructuringErrors = new DestructuringErrors\n  let init = this.parseExpression(true, refDestructuringErrors)\n  if (this.type === tt._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n    this.toAssignable(init)\n    this.checkLVal(init)\n    this.checkPatternErrors(refDestructuringErrors, true)\n    return this.parseForIn(node, init)\n  } else {\n    this.checkExpressionErrors(refDestructuringErrors, true)\n  }\n  return this.parseFor(node, init)\n}\n\npp.parseFunctionStatement = function(node, isAsync) {\n  this.next()\n  return this.parseFunction(node, true, false, isAsync)\n}\n\npp.isFunction = function() {\n  return this.type === tt._function || this.isAsyncFunction()\n}\n\npp.parseIfStatement = function(node) {\n  this.next()\n  node.test = this.parseParenExpression()\n  // allow function declarations in branches, but only in non-strict mode\n  node.consequent = this.parseStatement(!this.strict && this.isFunction())\n  node.alternate = this.eat(tt._else) ? this.parseStatement(!this.strict && this.isFunction()) : null\n  return this.finishNode(node, \"IfStatement\")\n}\n\npp.parseReturnStatement = function(node) {\n  if (!this.inFunction && !this.options.allowReturnOutsideFunction)\n    this.raise(this.start, \"'return' outside of function\")\n  this.next()\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (this.eat(tt.semi) || this.insertSemicolon()) node.argument = null\n  else { node.argument = this.parseExpression(); this.semicolon() }\n  return this.finishNode(node, \"ReturnStatement\")\n}\n\npp.parseSwitchStatement = function(node) {\n  this.next()\n  node.discriminant = this.parseParenExpression()\n  node.cases = []\n  this.expect(tt.braceL)\n  this.labels.push(switchLabel)\n  this.enterLexicalScope()\n\n  // Statements under must be grouped (by label) in SwitchCase\n  // nodes. `cur` is used to keep the node that we are currently\n  // adding statements to.\n\n  let cur\n  for (let sawDefault = false; this.type != tt.braceR;) {\n    if (this.type === tt._case || this.type === tt._default) {\n      let isCase = this.type === tt._case\n      if (cur) this.finishNode(cur, \"SwitchCase\")\n      node.cases.push(cur = this.startNode())\n      cur.consequent = []\n      this.next()\n      if (isCase) {\n        cur.test = this.parseExpression()\n      } else {\n        if (sawDefault) this.raiseRecoverable(this.lastTokStart, \"Multiple default clauses\")\n        sawDefault = true\n        cur.test = null\n      }\n      this.expect(tt.colon)\n    } else {\n      if (!cur) this.unexpected()\n      cur.consequent.push(this.parseStatement(true))\n    }\n  }\n  this.exitLexicalScope()\n  if (cur) this.finishNode(cur, \"SwitchCase\")\n  this.next() // Closing brace\n  this.labels.pop()\n  return this.finishNode(node, \"SwitchStatement\")\n}\n\npp.parseThrowStatement = function(node) {\n  this.next()\n  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\n    this.raise(this.lastTokEnd, \"Illegal newline after throw\")\n  node.argument = this.parseExpression()\n  this.semicolon()\n  return this.finishNode(node, \"ThrowStatement\")\n}\n\n// Reused empty array added for node fields that are always empty.\n\nconst empty = []\n\npp.parseTryStatement = function(node) {\n  this.next()\n  node.block = this.parseBlock()\n  node.handler = null\n  if (this.type === tt._catch) {\n    let clause = this.startNode()\n    this.next()\n    this.expect(tt.parenL)\n    clause.param = this.parseBindingAtom()\n    this.enterLexicalScope()\n    this.checkLVal(clause.param, \"let\")\n    this.expect(tt.parenR)\n    clause.body = this.parseBlock(false)\n    this.exitLexicalScope()\n    node.handler = this.finishNode(clause, \"CatchClause\")\n  }\n  node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null\n  if (!node.handler && !node.finalizer)\n    this.raise(node.start, \"Missing catch or finally clause\")\n  return this.finishNode(node, \"TryStatement\")\n}\n\npp.parseVarStatement = function(node, kind) {\n  this.next()\n  this.parseVar(node, false, kind)\n  this.semicolon()\n  return this.finishNode(node, \"VariableDeclaration\")\n}\n\npp.parseWhileStatement = function(node) {\n  this.next()\n  node.test = this.parseParenExpression()\n  this.labels.push(loopLabel)\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  return this.finishNode(node, \"WhileStatement\")\n}\n\npp.parseWithStatement = function(node) {\n  if (this.strict) this.raise(this.start, \"'with' in strict mode\")\n  this.next()\n  node.object = this.parseParenExpression()\n  node.body = this.parseStatement(false)\n  return this.finishNode(node, \"WithStatement\")\n}\n\npp.parseEmptyStatement = function(node) {\n  this.next()\n  return this.finishNode(node, \"EmptyStatement\")\n}\n\npp.parseLabeledStatement = function(node, maybeName, expr) {\n  for (let i = 0; i < this.labels.length; ++i)\n    if (this.labels[i].name === maybeName) this.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\")\n  let kind = this.type.isLoop ? \"loop\" : this.type === tt._switch ? \"switch\" : null\n  for (let i = this.labels.length - 1; i >= 0; i--) {\n    let label = this.labels[i]\n    if (label.statementStart == node.start) {\n      label.statementStart = this.start\n      label.kind = kind\n    } else break\n  }\n  this.labels.push({name: maybeName, kind: kind, statementStart: this.start})\n  node.body = this.parseStatement(true)\n  if (node.body.type == \"ClassDeclaration\" ||\n      node.body.type == \"VariableDeclaration\" && node.body.kind != \"var\" ||\n      node.body.type == \"FunctionDeclaration\" && (this.strict || node.body.generator))\n    this.raiseRecoverable(node.body.start, \"Invalid labeled declaration\")\n  this.labels.pop()\n  node.label = expr\n  return this.finishNode(node, \"LabeledStatement\")\n}\n\npp.parseExpressionStatement = function(node, expr) {\n  node.expression = expr\n  this.semicolon()\n  return this.finishNode(node, \"ExpressionStatement\")\n}\n\n// Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\n\npp.parseBlock = function(createNewLexicalScope = true) {\n  let node = this.startNode()\n  node.body = []\n  this.expect(tt.braceL)\n  if (createNewLexicalScope) {\n    this.enterLexicalScope()\n  }\n  while (!this.eat(tt.braceR)) {\n    let stmt = this.parseStatement(true)\n    node.body.push(stmt)\n  }\n  if (createNewLexicalScope) {\n    this.exitLexicalScope()\n  }\n  return this.finishNode(node, \"BlockStatement\")\n}\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\npp.parseFor = function(node, init) {\n  node.init = init\n  this.expect(tt.semi)\n  node.test = this.type === tt.semi ? null : this.parseExpression()\n  this.expect(tt.semi)\n  node.update = this.type === tt.parenR ? null : this.parseExpression()\n  this.expect(tt.parenR)\n  this.exitLexicalScope()\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  return this.finishNode(node, \"ForStatement\")\n}\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\npp.parseForIn = function(node, init) {\n  let type = this.type === tt._in ? \"ForInStatement\" : \"ForOfStatement\"\n  this.next()\n  node.left = init\n  node.right = this.parseExpression()\n  this.expect(tt.parenR)\n  this.exitLexicalScope()\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  return this.finishNode(node, type)\n}\n\n// Parse a list of variable declarations.\n\npp.parseVar = function(node, isFor, kind) {\n  node.declarations = []\n  node.kind = kind\n  for (;;) {\n    let decl = this.startNode()\n    this.parseVarId(decl, kind)\n    if (this.eat(tt.eq)) {\n      decl.init = this.parseMaybeAssign(isFor)\n    } else if (kind === \"const\" && !(this.type === tt._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\")))) {\n      this.unexpected()\n    } else if (decl.id.type != \"Identifier\" && !(isFor && (this.type === tt._in || this.isContextual(\"of\")))) {\n      this.raise(this.lastTokEnd, \"Complex binding patterns require an initialization value\")\n    } else {\n      decl.init = null\n    }\n    node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"))\n    if (!this.eat(tt.comma)) break\n  }\n  return node\n}\n\npp.parseVarId = function(decl, kind) {\n  decl.id = this.parseBindingAtom(kind)\n  this.checkLVal(decl.id, kind, false)\n}\n\n// Parse a function declaration or literal (depending on the\n// `isStatement` parameter).\n\npp.parseFunction = function(node, isStatement, allowExpressionBody, isAsync) {\n  this.initFunction(node)\n  if (this.options.ecmaVersion >= 6 && !isAsync)\n    node.generator = this.eat(tt.star)\n  if (this.options.ecmaVersion >= 8)\n    node.async = !!isAsync\n\n  if (isStatement) {\n    node.id = isStatement === \"nullableID\" && this.type != tt.name ? null : this.parseIdent()\n    if (node.id) {\n      this.checkLVal(node.id, \"var\")\n    }\n  }\n\n  let oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction\n  this.inGenerator = node.generator\n  this.inAsync = node.async\n  this.yieldPos = 0\n  this.awaitPos = 0\n  this.inFunction = true\n  this.enterFunctionScope()\n\n  if (!isStatement)\n    node.id = this.type == tt.name ? this.parseIdent() : null\n\n  this.parseFunctionParams(node)\n  this.parseFunctionBody(node, allowExpressionBody)\n\n  this.inGenerator = oldInGen\n  this.inAsync = oldInAsync\n  this.yieldPos = oldYieldPos\n  this.awaitPos = oldAwaitPos\n  this.inFunction = oldInFunc\n  return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\")\n}\n\npp.parseFunctionParams = function(node) {\n  this.expect(tt.parenL)\n  node.params = this.parseBindingList(tt.parenR, false, this.options.ecmaVersion >= 8, true)\n  this.checkYieldAwaitInDefaultParams()\n}\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\npp.parseClass = function(node, isStatement) {\n  this.next()\n\n  this.parseClassId(node, isStatement)\n  this.parseClassSuper(node)\n  let classBody = this.startNode()\n  let hadConstructor = false\n  classBody.body = []\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    if (this.eat(tt.semi)) continue\n    let method = this.startNode()\n    let isGenerator = this.eat(tt.star)\n    let isAsync = false\n    let isMaybeStatic = this.type === tt.name && this.value === \"static\"\n    this.parsePropertyName(method)\n    method.static = isMaybeStatic && this.type !== tt.parenL\n    if (method.static) {\n      if (isGenerator) this.unexpected()\n      isGenerator = this.eat(tt.star)\n      this.parsePropertyName(method)\n    }\n    if (this.options.ecmaVersion >= 8 && !isGenerator && !method.computed &&\n        method.key.type === \"Identifier\" && method.key.name === \"async\" && this.type !== tt.parenL &&\n        !this.canInsertSemicolon()) {\n      isAsync = true\n      this.parsePropertyName(method)\n    }\n    method.kind = \"method\"\n    let isGetSet = false\n    if (!method.computed) {\n      let {key} = method\n      if (!isGenerator && !isAsync && key.type === \"Identifier\" && this.type !== tt.parenL && (key.name === \"get\" || key.name === \"set\")) {\n        isGetSet = true\n        method.kind = key.name\n        key = this.parsePropertyName(method)\n      }\n      if (!method.static && (key.type === \"Identifier\" && key.name === \"constructor\" ||\n          key.type === \"Literal\" && key.value === \"constructor\")) {\n        if (hadConstructor) this.raise(key.start, \"Duplicate constructor in the same class\")\n        if (isGetSet) this.raise(key.start, \"Constructor can't have get/set modifier\")\n        if (isGenerator) this.raise(key.start, \"Constructor can't be a generator\")\n        if (isAsync) this.raise(key.start, \"Constructor can't be an async method\")\n        method.kind = \"constructor\"\n        hadConstructor = true\n      }\n    }\n    this.parseClassMethod(classBody, method, isGenerator, isAsync)\n    if (isGetSet) {\n      let paramCount = method.kind === \"get\" ? 0 : 1\n      if (method.value.params.length !== paramCount) {\n        let start = method.value.start\n        if (method.kind === \"get\")\n          this.raiseRecoverable(start, \"getter should have no params\")\n        else\n          this.raiseRecoverable(start, \"setter should have exactly one param\")\n      } else {\n        if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\")\n          this.raiseRecoverable(method.value.params[0].start, \"Setter cannot use rest params\")\n      }\n    }\n  }\n  node.body = this.finishNode(classBody, \"ClassBody\")\n  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n}\n\npp.parseClassMethod = function(classBody, method, isGenerator, isAsync) {\n  method.value = this.parseMethod(isGenerator, isAsync)\n  classBody.body.push(this.finishNode(method, \"MethodDefinition\"))\n}\n\npp.parseClassId = function(node, isStatement) {\n  node.id = this.type === tt.name ? this.parseIdent() : isStatement === true ? this.unexpected() : null\n}\n\npp.parseClassSuper = function(node) {\n  node.superClass = this.eat(tt._extends) ? this.parseExprSubscripts() : null\n}\n\n// Parses module export declaration.\n\npp.parseExport = function(node, exports) {\n  this.next()\n  // export * from '...'\n  if (this.eat(tt.star)) {\n    this.expectContextual(\"from\")\n    node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()\n    this.semicolon()\n    return this.finishNode(node, \"ExportAllDeclaration\")\n  }\n  if (this.eat(tt._default)) { // export default ...\n    this.checkExport(exports, \"default\", this.lastTokStart)\n    let isAsync\n    if (this.type === tt._function || (isAsync = this.isAsyncFunction())) {\n      let fNode = this.startNode()\n      this.next()\n      if (isAsync) this.next()\n      node.declaration = this.parseFunction(fNode, \"nullableID\", false, isAsync)\n    } else if (this.type === tt._class) {\n      let cNode = this.startNode()\n      node.declaration = this.parseClass(cNode, \"nullableID\")\n    } else {\n      node.declaration = this.parseMaybeAssign()\n      this.semicolon()\n    }\n    return this.finishNode(node, \"ExportDefaultDeclaration\")\n  }\n  // export var|const|let|function|class ...\n  if (this.shouldParseExportStatement()) {\n    node.declaration = this.parseStatement(true)\n    if (node.declaration.type === \"VariableDeclaration\")\n      this.checkVariableExport(exports, node.declaration.declarations)\n    else\n      this.checkExport(exports, node.declaration.id.name, node.declaration.id.start)\n    node.specifiers = []\n    node.source = null\n  } else { // export { x, y as z } [from '...']\n    node.declaration = null\n    node.specifiers = this.parseExportSpecifiers(exports)\n    if (this.eatContextual(\"from\")) {\n      node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()\n    } else {\n      // check for keywords used as local names\n      for (let i = 0; i < node.specifiers.length; i++) {\n        if (this.keywords.test(node.specifiers[i].local.name) || this.reservedWords.test(node.specifiers[i].local.name)) {\n          this.unexpected(node.specifiers[i].local.start)\n        }\n      }\n\n      node.source = null\n    }\n    this.semicolon()\n  }\n  return this.finishNode(node, \"ExportNamedDeclaration\")\n}\n\npp.checkExport = function(exports, name, pos) {\n  if (!exports) return\n  if (has(exports, name))\n    this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\")\n  exports[name] = true\n}\n\npp.checkPatternExport = function(exports, pat) {\n  let type = pat.type\n  if (type == \"Identifier\")\n    this.checkExport(exports, pat.name, pat.start)\n  else if (type == \"ObjectPattern\")\n    for (let i = 0; i < pat.properties.length; ++i)\n      this.checkPatternExport(exports, pat.properties[i].value)\n  else if (type == \"ArrayPattern\")\n    for (let i = 0; i < pat.elements.length; ++i) {\n      let elt = pat.elements[i]\n      if (elt) this.checkPatternExport(exports, elt)\n    }\n  else if (type == \"AssignmentPattern\")\n    this.checkPatternExport(exports, pat.left)\n  else if (type == \"ParenthesizedExpression\")\n    this.checkPatternExport(exports, pat.expression)\n}\n\npp.checkVariableExport = function(exports, decls) {\n  if (!exports) return\n  for (let i = 0; i < decls.length; i++)\n    this.checkPatternExport(exports, decls[i].id)\n}\n\npp.shouldParseExportStatement = function() {\n  return this.type.keyword === \"var\" ||\n    this.type.keyword === \"const\" ||\n    this.type.keyword === \"class\" ||\n    this.type.keyword === \"function\" ||\n    this.isLet() ||\n    this.isAsyncFunction()\n}\n\n// Parses a comma-separated list of module exports.\n\npp.parseExportSpecifiers = function(exports) {\n  let nodes = [], first = true\n  // export { x, y as z } [from '...']\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    if (!first) {\n      this.expect(tt.comma)\n      if (this.afterTrailingComma(tt.braceR)) break\n    } else first = false\n\n    let node = this.startNode()\n    node.local = this.parseIdent(true)\n    node.exported = this.eatContextual(\"as\") ? this.parseIdent(true) : node.local\n    this.checkExport(exports, node.exported.name, node.exported.start)\n    nodes.push(this.finishNode(node, \"ExportSpecifier\"))\n  }\n  return nodes\n}\n\n// Parses import declaration.\n\npp.parseImport = function(node) {\n  this.next()\n  // import '...'\n  if (this.type === tt.string) {\n    node.specifiers = empty\n    node.source = this.parseExprAtom()\n  } else {\n    node.specifiers = this.parseImportSpecifiers()\n    this.expectContextual(\"from\")\n    node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()\n  }\n  this.semicolon()\n  return this.finishNode(node, \"ImportDeclaration\")\n}\n\n// Parses a comma-separated list of module imports.\n\npp.parseImportSpecifiers = function() {\n  let nodes = [], first = true\n  if (this.type === tt.name) {\n    // import defaultObj, { x, y as z } from '...'\n    let node = this.startNode()\n    node.local = this.parseIdent()\n    this.checkLVal(node.local, \"let\")\n    nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"))\n    if (!this.eat(tt.comma)) return nodes\n  }\n  if (this.type === tt.star) {\n    let node = this.startNode()\n    this.next()\n    this.expectContextual(\"as\")\n    node.local = this.parseIdent()\n    this.checkLVal(node.local, \"let\")\n    nodes.push(this.finishNode(node, \"ImportNamespaceSpecifier\"))\n    return nodes\n  }\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    if (!first) {\n      this.expect(tt.comma)\n      if (this.afterTrailingComma(tt.braceR)) break\n    } else first = false\n\n    let node = this.startNode()\n    node.imported = this.parseIdent(true)\n    if (this.eatContextual(\"as\")) {\n      node.local = this.parseIdent()\n    } else {\n      node.local = node.imported\n      if (this.isKeyword(node.local.name)) this.unexpected(node.local.start)\n      if (this.reservedWordsStrict.test(node.local.name)) this.raiseRecoverable(node.local.start, \"The keyword '\" + node.local.name + \"' is reserved\")\n    }\n    this.checkLVal(node.local, \"let\")\n    nodes.push(this.finishNode(node, \"ImportSpecifier\"))\n  }\n  return nodes\n}\n"]}