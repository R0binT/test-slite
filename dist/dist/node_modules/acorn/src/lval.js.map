{"version":3,"sources":["../../../../node_modules/acorn/src/lval.js"],"names":["pp","prototype","toAssignable","node","isBinding","options","ecmaVersion","type","inAsync","name","raise","start","i","properties","length","prop","kind","key","value","toAssignableList","elements","operator","left","end","expression","exprList","last","arg","argument","unexpected","elt","parseSpread","refDestructuringErrors","startNode","next","parseMaybeAssign","finishNode","parseRest","allowNonIdent","parseIdent","bracketL","parseBindingAtom","parseBindingList","bracketR","braceL","parseObj","close","allowEmpty","allowTrailingComma","elts","first","eat","expect","comma","push","afterTrailingComma","ellipsis","rest","parseBindingListItem","elem","parseMaybeDefault","startLoc","param","startPos","eq","startNodeAt","right","checkLVal","expr","bindingType","checkClashes","strict","reservedWordsStrictBind","test","raiseRecoverable","canDeclareVarName","canDeclareLexicalName","declareVarName","declareLexicalName"],"mappings":"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","file":"lval.js","sourcesContent":["import {types as tt} from \"./tokentype\"\nimport {Parser} from \"./state\"\nimport {has} from \"./util\"\n\nconst pp = Parser.prototype\n\n// Convert existing expression atom to assignable pattern\n// if possible.\n\npp.toAssignable = function(node, isBinding) {\n  if (this.options.ecmaVersion >= 6 && node) {\n    switch (node.type) {\n    case \"Identifier\":\n      if (this.inAsync && node.name === \"await\")\n        this.raise(node.start, \"Can not use 'await' as identifier inside an async function\")\n      break\n\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n      break\n\n    case \"ObjectExpression\":\n      node.type = \"ObjectPattern\"\n      for (let i = 0; i < node.properties.length; i++) {\n        let prop = node.properties[i]\n        if (prop.kind !== \"init\") this.raise(prop.key.start, \"Object pattern can't contain getter or setter\")\n        this.toAssignable(prop.value, isBinding)\n      }\n      break\n\n    case \"ArrayExpression\":\n      node.type = \"ArrayPattern\"\n      this.toAssignableList(node.elements, isBinding)\n      break\n\n    case \"AssignmentExpression\":\n      if (node.operator === \"=\") {\n        node.type = \"AssignmentPattern\"\n        delete node.operator\n        this.toAssignable(node.left, isBinding)\n        // falls through to AssignmentPattern\n      } else {\n        this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\")\n        break\n      }\n\n    case \"AssignmentPattern\":\n      break\n\n    case \"ParenthesizedExpression\":\n      node.expression = this.toAssignable(node.expression, isBinding)\n      break\n\n    case \"MemberExpression\":\n      if (!isBinding) break\n\n    default:\n      this.raise(node.start, \"Assigning to rvalue\")\n    }\n  }\n  return node\n}\n\n// Convert list of expression atoms to binding list.\n\npp.toAssignableList = function(exprList, isBinding) {\n  let end = exprList.length\n  if (end) {\n    let last = exprList[end - 1]\n    if (last && last.type == \"RestElement\") {\n      --end\n    } else if (last && last.type == \"SpreadElement\") {\n      last.type = \"RestElement\"\n      let arg = last.argument\n      this.toAssignable(arg, isBinding)\n      if (arg.type !== \"Identifier\" && arg.type !== \"MemberExpression\" && arg.type !== \"ArrayPattern\")\n        this.unexpected(arg.start)\n      --end\n    }\n\n    if (isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\n      this.unexpected(last.argument.start)\n  }\n  for (let i = 0; i < end; i++) {\n    let elt = exprList[i]\n    if (elt) this.toAssignable(elt, isBinding)\n  }\n  return exprList\n}\n\n// Parses spread element.\n\npp.parseSpread = function(refDestructuringErrors) {\n  let node = this.startNode()\n  this.next()\n  node.argument = this.parseMaybeAssign(false, refDestructuringErrors)\n  return this.finishNode(node, \"SpreadElement\")\n}\n\npp.parseRest = function(allowNonIdent) {\n  let node = this.startNode()\n  this.next()\n\n  // RestElement inside of a function parameter must be an identifier\n  if (allowNonIdent) node.argument = this.type === tt.name ? this.parseIdent() : this.unexpected()\n  else node.argument = this.type === tt.name || this.type === tt.bracketL ? this.parseBindingAtom() : this.unexpected()\n\n  return this.finishNode(node, \"RestElement\")\n}\n\n// Parses lvalue (assignable) atom.\n\npp.parseBindingAtom = function() {\n  if (this.options.ecmaVersion < 6) return this.parseIdent()\n  switch (this.type) {\n  case tt.name:\n    return this.parseIdent()\n\n  case tt.bracketL:\n    let node = this.startNode()\n    this.next()\n    node.elements = this.parseBindingList(tt.bracketR, true, true)\n    return this.finishNode(node, \"ArrayPattern\")\n\n  case tt.braceL:\n    return this.parseObj(true)\n\n  default:\n    this.unexpected()\n  }\n}\n\npp.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowNonIdent) {\n  let elts = [], first = true\n  while (!this.eat(close)) {\n    if (first) first = false\n    else this.expect(tt.comma)\n    if (allowEmpty && this.type === tt.comma) {\n      elts.push(null)\n    } else if (allowTrailingComma && this.afterTrailingComma(close)) {\n      break\n    } else if (this.type === tt.ellipsis) {\n      let rest = this.parseRest(allowNonIdent)\n      this.parseBindingListItem(rest)\n      elts.push(rest)\n      if (this.type === tt.comma) this.raise(this.start, \"Comma is not permitted after the rest element\")\n      this.expect(close)\n      break\n    } else {\n      let elem = this.parseMaybeDefault(this.start, this.startLoc)\n      this.parseBindingListItem(elem)\n      elts.push(elem)\n    }\n  }\n  return elts\n}\n\npp.parseBindingListItem = function(param) {\n  return param\n}\n\n// Parses assignment pattern around given atom if possible.\n\npp.parseMaybeDefault = function(startPos, startLoc, left) {\n  left = left || this.parseBindingAtom()\n  if (this.options.ecmaVersion < 6 || !this.eat(tt.eq)) return left\n  let node = this.startNodeAt(startPos, startLoc)\n  node.left = left\n  node.right = this.parseMaybeAssign()\n  return this.finishNode(node, \"AssignmentPattern\")\n}\n\n// Verify that a node is an lval — something that can be assigned\n// to.\n// bindingType can be either:\n// 'var' indicating that the lval creates a 'var' binding\n// 'let' indicating that the lval creates a lexical ('let' or 'const') binding\n// 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references\n\npp.checkLVal = function(expr, bindingType, checkClashes) {\n  switch (expr.type) {\n  case \"Identifier\":\n    if (this.strict && this.reservedWordsStrictBind.test(expr.name))\n      this.raiseRecoverable(expr.start, (bindingType ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\")\n    if (checkClashes) {\n      if (has(checkClashes, expr.name))\n        this.raiseRecoverable(expr.start, \"Argument name clash\")\n      checkClashes[expr.name] = true\n    }\n    if (bindingType && bindingType !== \"none\") {\n      if (\n        bindingType === \"var\" && !this.canDeclareVarName(expr.name) ||\n        bindingType !== \"var\" && !this.canDeclareLexicalName(expr.name)\n      ) {\n        this.raiseRecoverable(expr.start, `Identifier '${expr.name}' has already been declared`)\n      }\n      if (bindingType === \"var\") {\n        this.declareVarName(expr.name)\n      } else {\n        this.declareLexicalName(expr.name)\n      }\n    }\n    break\n\n  case \"MemberExpression\":\n    if (bindingType) this.raiseRecoverable(expr.start, (bindingType ? \"Binding\" : \"Assigning to\") + \" member expression\")\n    break\n\n  case \"ObjectPattern\":\n    for (let i = 0; i < expr.properties.length; i++)\n      this.checkLVal(expr.properties[i].value, bindingType, checkClashes)\n    break\n\n  case \"ArrayPattern\":\n    for (let i = 0; i < expr.elements.length; i++) {\n      let elem = expr.elements[i]\n      if (elem) this.checkLVal(elem, bindingType, checkClashes)\n    }\n    break\n\n  case \"AssignmentPattern\":\n    this.checkLVal(expr.left, bindingType, checkClashes)\n    break\n\n  case \"RestElement\":\n    this.checkLVal(expr.argument, bindingType, checkClashes)\n    break\n\n  case \"ParenthesizedExpression\":\n    this.checkLVal(expr.expression, bindingType, checkClashes)\n    break\n\n  default:\n    this.raise(expr.start, (bindingType ? \"Binding\" : \"Assigning to\") + \" rvalue\")\n  }\n}\n"]}